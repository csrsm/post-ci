(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{543:function(t,a,e){"use strict";e.r(a);var n=e(5),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop"}},[t._v("#")]),t._v(" "),e("strong",[t._v("AOP")])]),t._v(" "),e("p",[t._v("面向切面编程，传统的面向对象编程（OOP）开发中的代码逻辑是至上而下的，在这些至上而下的过程中会产生一些横切性的问题，这些横切性问题和业务逻辑关系不大，会散落在代码的各个地方，难以维护，AOP的编程思想就是把业务逻辑和横切性问题进行分离，从而达到解藕的目的，使代码的重用性和开发效率更高。")]),t._v(" "),e("p",[t._v("Spring AOP是对AOP的一种实现。")]),t._v(" "),e("p",[t._v("AspectJ是对AOP的一种实现框架。")]),t._v(" "),e("p",[t._v("spring借助aspectj的语法，几种注解。")]),t._v(" "),e("h4",{attrs:{id:"应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" "),e("strong",[t._v("应用场景")])]),t._v(" "),e("p",[t._v("日志记录、权限验证、效率检查、事务管理等。")]),t._v(" "),e("h2",{attrs:{id:"aop-concepts"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop-concepts"}},[t._v("#")]),t._v(" "),e("strong",[t._v("AOP Concepts")])]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("Joinpoint")]),t._v("：连接点，目标对象中的方法。")]),t._v(" "),e("li",[e("strong",[t._v("Aspect")]),t._v("：切面，连接点、切点、通知等信息的载体，spring管理(声明成spring bean)。")]),t._v(" "),e("li",[e("strong",[t._v("pointcut")]),t._v("：切点，连接点的集合。")]),t._v(" "),e("li",[e("strong",[t._v("target object")]),t._v("：目标对象，原始对象。")]),t._v(" "),e("li",[e("strong",[t._v("AOP proxy")]),t._v("：代理对象，包含了原始对象的代码和增强的代码（横切性），使用JDK代理时，与目标对象不等，使用CGLIB时，与目标对象相等，两者均与目标对象实现的接口相等。")]),t._v(" "),e("li",[e("strong",[t._v("Weaving")]),t._v("：织入，把代理逻辑加到目标对象上的过程。")]),t._v(" "),e("li",[e("strong",[t._v("Introduction")]),t._v("：")]),t._v(" "),e("li",[e("strong",[t._v("Advice")]),t._v("：通知，包含位置（before、after、around）以及逻辑。")])]),t._v(" "),e("h3",{attrs:{id:"声明pointcut"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明pointcut"}},[t._v("#")]),t._v(" "),e("strong",[t._v("声明Pointcut")])]),t._v(" "),e("p",[t._v("通知指定切点可以通过逻辑运算符指定多个。")]),t._v(" "),e("p",[e("strong",[t._v("1.execution")]),t._v("：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)\n问号表示可有可无，其中各项如下：\nmodifiers-pattern：方法可见性，如public、protected。\nret-type-pattern：方法返回值类型，如int、void。\ndeclaring-type-pattern：方法所在类的全路径名，如com.spring.Aspect。\nname-pattern：方法名类型。\nparam-pattern：方法的参数类型，如java.lang.string。\nthrows-pattern：方法抛出的异常类型，如java.lang.Exception。\n##doc:https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples\n")])])]),e("p",[e("strong",[t._v("2.within")]),t._v("：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  与execution区别在于，execution最小的粒度可以匹配方法修饰符、返回值、参数等等。\n  within只能匹配包路径。如：within(com.xyz.service.*)\n")])])]),e("p",[e("strong",[t._v("3.args")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    args(java.lang.String)\n    与包名类名无关，只与参数类型、个数有关\n")])])]),e("p",[e("strong",[t._v("4.@annotation")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" @annotation(org.springframework.transaction.annotation.Transactional)\n 在切点上指定注解，则使用该注解的类会收到通知。\n")])])]),e("p",[e("strong",[t._v("5.this")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Pointcut(value = "this(com.cm.dao.IndexDao)")\nthis指向的是当前作用目标的代理对象。\njdk代理时，代理对象与目标对象不一致，不会生效\ngclib代理时，代理对象与目标对象一致，有效\n')])])]),e("p",[e("strong",[t._v("6.target")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Pointcut(value = "target(com.cm.dao.IndexDao)")\n目标对象不变。\n')])])]),e("h4",{attrs:{id:"jdk动态代理为什么只能是基于接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jdk动态代理为什么只能是基于接口"}},[t._v("#")]),t._v(" "),e("strong",[t._v("##jdk动态代理为什么只能是基于接口？")])]),t._v(" "),e("p",[t._v("jdk底层源码，在动态代理时，已经继承了Proxy类，java是单继承，所以要基于接口实现。")]),t._v(" "),e("h4",{attrs:{id:"cglib与jdk动态代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cglib与jdk动态代理"}},[t._v("#")]),t._v(" "),e("strong",[t._v("##CGLIB与JDK动态代理")])]),t._v(" "),e("p",[t._v("jdk动态代理需要目标对象实现一个或多个接口，当代理没有实现接口的继承的类时，使用CGLIB包。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("@EnableAspectJAutoProxy(proxyTargetClass = false)  ----JDK代理（默认使用）\nindexdao instanceof IndexDao（true）\nindexdao instanceof Proxy（true）\nindexdao instanceof IndexDaoImpl（false）\n@EnableAspectJAutoProxy(proxyTargetClass = true)   ----CGLIB代理\nindexdao instanceof IndexDao（true）\nindexdao instanceof Proxy（false）\nindexdao instanceof IndexDaoImpl（true）\n")])])]),e("h3",{attrs:{id:"通知-advice"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通知-advice"}},[t._v("#")]),t._v(" "),e("strong",[t._v("通知 Advice")])]),t._v(" "),e("p",[e("strong",[t._v("1.@before")]),t._v("：在连接点方法运行之前执行。")]),t._v(" "),e("p",[e("strong",[t._v("2.@After")]),t._v("：在连接点方法运行之后执行。")]),t._v(" "),e("p",[e("strong",[t._v("3.@Around")]),t._v("：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ProceedingJoinPoint与JoinPoint区别：\nProceedingJoinPoint继承了JoinPoint，proceed()是aop代理链执行的方法。\nJoinPoint的方法：\n1.Object[] getArgs();获取连接点方法运行的入参列表\n2.Object getTarget();获取连接点所在的目标对象\n3.Object getThis();获取连接点所在的代理对象本身\n4.Signature getSignature();获取连接点的方法签名对象\nproceed()有重载，有个带参数的方法，可以修改目标方法的参数\n⚠️proceed()方法需要执行，否则被aop的方法不会继续执行。\n⚠️该方法需要有返回值，返回proceed()，否则被aop的方法返回值为空。\n")])])]),e("h3",{attrs:{id:"aspect-introductions-扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aspect-introductions-扩展"}},[t._v("#")]),t._v(" "),e("strong",[t._v("aspect Introductions")]),t._v(" 扩展")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@DeclareParents(value="com.cm.dao.*+", defaultImpl= IndexDao.class)\npublic static Dao dao;\n当在该路径下类强转成Dao时，可以使用默认实现defaultImpl中的方法。\n')])])]),e("h3",{attrs:{id:"aspect-instantiation-models-切面实例化模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aspect-instantiation-models-切面实例化模型"}},[t._v("#")]),t._v(" "),e("strong",[t._v("Aspect Instantiation Models 切面实例化模型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Aspect("perthis(this(com.cm.dao.Dao))")\n可以设置切面的作用域，单例、原型\n')])])]),e("h4",{attrs:{id:"spring-aop有两种风格"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop有两种风格"}},[t._v("#")]),t._v(" "),e("strong",[t._v("spring-aop有两种风格：")])]),t._v(" "),e("ol",[e("li",[t._v("@AspectJ注解风格（推荐）")]),t._v(" "),e("li",[t._v("xml风格（）")])]),t._v(" "),e("h3",{attrs:{id:"设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式：")]),t._v(" "),e("p",[t._v("工厂模式：spring BeanFactory或ApplicationContext创建对象")]),t._v(" "),e("p",[t._v("代理模式：jdk proxy动态代理")]),t._v(" "),e("p",[t._v("单例模式：依赖注入默认单例模式")])])}),[],!1,null,null,null);a.default=s.exports}}]);