(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{501:function(t,a,_){"use strict";_.r(a);var e=_(5),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"一、多线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、多线程"}},[t._v("#")]),t._v(" 一、多线程")]),t._v(" "),_("h2",{attrs:{id:"_1-基础知识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-基础知识"}},[t._v("#")]),t._v(" 1.基础知识")]),t._v(" "),_("h3",{attrs:{id:"_1-线程的两种创建方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程的两种创建方式"}},[t._v("#")]),t._v(" （1）线程的两种创建方式：")]),t._v(" "),_("ul",[_("li",[t._v("继承Thread类。new MyThread().start()")]),t._v(" "),_("li",[t._v("实现Runnable接口。new MyThread(new MyRunnable()).start()")]),t._v(" "),_("li",[t._v("lamda表达式。")])]),t._v(" "),_("h3",{attrs:{id:"_2-启动线程的三种方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-启动线程的三种方式"}},[t._v("#")]),t._v(" （2）启动线程的三种方式")]),t._v(" "),_("ul",[_("li",[t._v("Thread类")]),t._v(" "),_("li",[t._v("Runnable接口")]),t._v(" "),_("li",[t._v("Executors线程池（使用的也是上述两种之一）")])]),t._v(" "),_("h3",{attrs:{id:"_3-线程常用方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程常用方法"}},[t._v("#")]),t._v(" （3）线程常用方法")]),t._v(" "),_("ul",[_("li",[t._v("sleep()")]),t._v(" "),_("li",[t._v("yield()")]),t._v(" "),_("li",[t._v("join()")])]),t._v(" "),_("blockquote",[_("p",[t._v("sleep()方法和wait()方法的区别：")]),t._v(" "),_("p",[t._v("sleep()方法是Thread类的方法，wait()方法是Object类提供的方法，sleep方法通过设置睡眠时间来唤醒线程，不释放锁，wait方法只能通过notify等方法唤醒线程，会释放锁。")])]),t._v(" "),_("h3",{attrs:{id:"_4-线程状态迁移"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-线程状态迁移"}},[t._v("#")]),t._v(" （4）线程状态迁移")]),t._v(" "),_("p",[t._v("java线程状态：new、runnable（ready、running）、teminated、timedWaiting、waiting、blocked")]),t._v(" "),_("p",[_("img",{attrs:{src:"img/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB.jpg",alt:"线程状态迁移"}})]),t._v(" "),_("h3",{attrs:{id:"_5-synchronized关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-synchronized关键字"}},[t._v("#")]),t._v(" （5）synchronized关键字")]),t._v(" "),_("p",[t._v("既保证了原子性又保证了可见性。 锁只针对于对象。")]),t._v(" "),_("p",[t._v("synchronized(Object)： 不能锁定String常量、Integer、Long等")]),t._v(" "),_("blockquote",[_("p",[t._v("可重入锁：一个同步方法调用另一个同步方法，一个线程已经拥有了某个对象的锁，再次申请时仍然会得到该对象的锁，也就是说synchronized获得的锁是可重入的。")]),t._v(" "),_("p",[t._v("程序中出现异常时，默认情况下锁会被释放。")]),t._v(" "),_("p",[t._v("锁定方法和非锁定方法可以同时执行。")])]),t._v(" "),_("p",[_("strong",[t._v("底层实现")]),t._v("：JDK早期时是重量级锁，需要申请操作系统的锁（内核态）。后续的改进引入锁升级的概念，效率大幅提高。")]),t._v(" "),_("p",[t._v("第一个申请锁的对象，会在markword记录这个线程的线程号，并不会给该对象加锁（偏向锁）")]),t._v(" "),_("p",[t._v("如果有线程争用，则会升级为自旋锁（用户态），自旋10次以后还是无法得到锁后，则会升级为重量级锁，申请操作系统的锁。")]),t._v(" "),_("blockquote",[_("p",[t._v("自旋锁占用cpu资源，不适用于执行时间长（加锁代码），且线程较多的情况。")]),t._v(" "),_("p",[t._v("操作系统的锁不占用cpu资源，竞争的线程是在等待队列中，不占用cpu，所以执行时间长、线程数多尽量使用synchronized。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);