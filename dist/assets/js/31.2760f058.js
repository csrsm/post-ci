(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{523:function(a,t,s){"use strict";s.r(t);var r=s(5),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"设计模式-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计模式-proxy"}},[a._v("#")]),a._v(" "),s("strong",[a._v("设计模式：proxy")])]),a._v(" "),s("h6",{attrs:{id:"代理-增强一个对象的功能。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代理-增强一个对象的功能。"}},[a._v("#")]),a._v(" 代理：增强一个对象的功能。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("目标对象：被增强的对象")])]),a._v(" "),s("li",[s("p",[a._v("代理对象：增强后的对象")]),a._v(" "),s("p",[a._v("不是绝对的，会根据代码发生改变。")])])]),a._v(" "),s("h2",{attrs:{id:"java实现代理的两种方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java实现代理的两种方式"}},[a._v("#")]),a._v(" Java实现代理的两种方式：")]),a._v(" "),s("h3",{attrs:{id:"_1-静态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-静态代理"}},[a._v("#")]),a._v(" "),s("strong",[a._v("1.静态代理")])]),a._v(" "),s("p",[s("strong",[a._v("## 如果在不确定的情况下，尽量不要使用静态代理")])]),a._v(" "),s("h4",{attrs:{id:"继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" "),s("strong",[a._v("继承")]),a._v("：")]),a._v(" "),s("p",[a._v("代理对象继承目标对象，重写目标对象的方法。")]),a._v(" "),s("p",[a._v("缺点：会导致代理类非常多，非常复杂。")]),a._v(" "),s("h4",{attrs:{id:"聚合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#聚合"}},[a._v("#")]),a._v(" "),s("strong",[a._v("聚合：")])]),a._v(" "),s("p",[a._v("目标对象和代理对象实现同一接口，代理对象中，包含目标对象。实现同一接口是为了对外提供一致的api")]),a._v(" "),s("p",[a._v("缺点：也会导致代理类过多，但是比继承少一些。")]),a._v(" "),s("h3",{attrs:{id:"_2-动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态代理"}},[a._v("#")]),a._v(" 2.动态代理")]),a._v(" "),s("p",[a._v("通过代码动态产生代理对象类。")]),a._v(" "),s("h3",{attrs:{id:"自己模拟的动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自己模拟的动态代理"}},[a._v("#")]),a._v(" "),s("strong",[a._v("自己模拟的动态代理")])]),a._v(" "),s("p",[a._v(".java --\x3e .class --\x3e 通过classloader 加载到 jvm中 ，以byte形式存在 --\x3e object对象")]),a._v(" "),s("p",[a._v("不需要手动创建类文件，通过接口反射生成类文件，调用第三方的编译技术，动态编译这个产生的类文件成class文件，继而利用classloader（动态产生的class不在工程当中，所以需要使用URLClassLoader）把这个动态编译的类加载到jvm中，最后通过反射把这个类实例化。")]),a._v(" "),s("p",[a._v("缺点：生成文件、动态编译文件、IO操作效率慢、需要URLclassloader")]),a._v(" "),s("p",[a._v("##判断对象是否相同的前提，是否是同一个类加载器加载的类。")]),a._v(" "),s("h3",{attrs:{id:"jdk动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk动态代理"}},[a._v("#")]),a._v(" "),s("strong",[a._v("JDK动态代理")])]),a._v(" "),s("p",[a._v("通过接口反射的方法 --\x3ebyte字节码 --\x3e object对象(通过一个native方法，底层使用c++实现)")]),a._v(" "),s("h3",{attrs:{id:"cglib代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cglib代理"}},[a._v("#")]),a._v(" "),s("strong",[a._v("CGLib代理")])]),a._v(" "),s("p",[a._v("使用asm实现对字节码的操作，与jdk动态代理的区别在于，jdk基于实现接口（因为jdk）")])])}),[],!1,null,null,null);t.default=v.exports}}]);