<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | Csrsm</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/csrsm-blog/favicon.ico">
    <meta name="description" content="This is my blog">
    <link rel="preload" href="/csrsm-blog/assets/css/0.styles.55ca18c7.css" as="style"><link rel="preload" href="/csrsm-blog/assets/js/app.454ee9d8.js" as="script"><link rel="preload" href="/csrsm-blog/assets/js/7.dcf110ed.js" as="script"><link rel="preload" href="/csrsm-blog/assets/js/49.ada3dd91.js" as="script"><link rel="prefetch" href="/csrsm-blog/assets/js/1.21d8b032.js"><link rel="prefetch" href="/csrsm-blog/assets/js/10.f7727560.js"><link rel="prefetch" href="/csrsm-blog/assets/js/11.b24ae5b9.js"><link rel="prefetch" href="/csrsm-blog/assets/js/12.7b019a26.js"><link rel="prefetch" href="/csrsm-blog/assets/js/13.e177012a.js"><link rel="prefetch" href="/csrsm-blog/assets/js/14.d1946efc.js"><link rel="prefetch" href="/csrsm-blog/assets/js/15.1196f0f2.js"><link rel="prefetch" href="/csrsm-blog/assets/js/16.3674e8a7.js"><link rel="prefetch" href="/csrsm-blog/assets/js/17.59e378b2.js"><link rel="prefetch" href="/csrsm-blog/assets/js/18.b5d363ed.js"><link rel="prefetch" href="/csrsm-blog/assets/js/19.2420e1e4.js"><link rel="prefetch" href="/csrsm-blog/assets/js/20.ad8dd5df.js"><link rel="prefetch" href="/csrsm-blog/assets/js/21.38820707.js"><link rel="prefetch" href="/csrsm-blog/assets/js/22.96d8d990.js"><link rel="prefetch" href="/csrsm-blog/assets/js/23.21b1b2ec.js"><link rel="prefetch" href="/csrsm-blog/assets/js/24.cc388ced.js"><link rel="prefetch" href="/csrsm-blog/assets/js/25.ad0002ee.js"><link rel="prefetch" href="/csrsm-blog/assets/js/26.ded936a4.js"><link rel="prefetch" href="/csrsm-blog/assets/js/27.ed36e5a3.js"><link rel="prefetch" href="/csrsm-blog/assets/js/28.ee1ac958.js"><link rel="prefetch" href="/csrsm-blog/assets/js/29.49ad9e73.js"><link rel="prefetch" href="/csrsm-blog/assets/js/3.4b96004a.js"><link rel="prefetch" href="/csrsm-blog/assets/js/30.4694b34a.js"><link rel="prefetch" href="/csrsm-blog/assets/js/31.2760f058.js"><link rel="prefetch" href="/csrsm-blog/assets/js/32.a901893a.js"><link rel="prefetch" href="/csrsm-blog/assets/js/33.2a9f0d8b.js"><link rel="prefetch" href="/csrsm-blog/assets/js/34.fc47d4fc.js"><link rel="prefetch" href="/csrsm-blog/assets/js/35.2d3765de.js"><link rel="prefetch" href="/csrsm-blog/assets/js/36.449567d0.js"><link rel="prefetch" href="/csrsm-blog/assets/js/37.4a627e0e.js"><link rel="prefetch" href="/csrsm-blog/assets/js/38.ae092217.js"><link rel="prefetch" href="/csrsm-blog/assets/js/39.7d481f19.js"><link rel="prefetch" href="/csrsm-blog/assets/js/4.2b8faf49.js"><link rel="prefetch" href="/csrsm-blog/assets/js/40.6aa2db47.js"><link rel="prefetch" href="/csrsm-blog/assets/js/41.b714f40b.js"><link rel="prefetch" href="/csrsm-blog/assets/js/42.c701cd24.js"><link rel="prefetch" href="/csrsm-blog/assets/js/43.a0d123b6.js"><link rel="prefetch" href="/csrsm-blog/assets/js/44.f476f304.js"><link rel="prefetch" href="/csrsm-blog/assets/js/45.9a86ee02.js"><link rel="prefetch" href="/csrsm-blog/assets/js/46.f9b38586.js"><link rel="prefetch" href="/csrsm-blog/assets/js/47.3e93fdd7.js"><link rel="prefetch" href="/csrsm-blog/assets/js/48.6b9a245e.js"><link rel="prefetch" href="/csrsm-blog/assets/js/5.21b74e30.js"><link rel="prefetch" href="/csrsm-blog/assets/js/50.9c058dcc.js"><link rel="prefetch" href="/csrsm-blog/assets/js/6.a8369353.js"><link rel="prefetch" href="/csrsm-blog/assets/js/8.547730f9.js"><link rel="prefetch" href="/csrsm-blog/assets/js/9.be1c3c52.js">
    <link rel="stylesheet" href="/csrsm-blog/assets/css/0.styles.55ca18c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(http://img.icoisini.xyz/background.jpg);" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/csrsm-blog/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          Csrsm
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/csrsm-blog/" class="navbar-link" data-v-e4145d0a>
            首页
          </a><a href="/csrsm-blog/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            Csrsm
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          Redis
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2022-05-02
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2022-05-19
    </span></section> <section class="post-links" data-v-4e23451f><a href="/csrsm-blog/posts/2022/03/28/jvm%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90.html" class="post-link" data-v-4e23451f>
      上一篇 : JVM-整体结构内存模型
    </a> <a href="/csrsm-blog/posts/2022/05/02/mysql%E4%BC%98%E5%8C%96.html" class="post-link" data-v-4e23451f>
      下一篇 : MySQL调优
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><h1 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h1> <h2 id="一、数据类型"><a href="#一、数据类型" class="header-anchor">#</a> 一、数据类型</h2> <h3 id="_1-字符串string"><a href="#_1-字符串string" class="header-anchor">#</a> 1.字符串String</h3> <h5 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景：</h5> <ol><li>缓存</li> <li>计数</li></ol> <h5 id="常用操作"><a href="#常用操作" class="header-anchor">#</a> 常用操作</h5> <ul><li>incr key：自增1</li> <li>decr key：自减1</li> <li>incrby key k：自增k</li> <li>decrby key k：自减k</li> <li>set key value：key是否存在都设置</li> <li>setnx key value：key 不存在，才设置</li> <li>set key value xx：key存在，才设置</li> <li>set ex：set+expire组合 原子性操作</li> <li>mget：批量获取key 原子操作 高效率，多次计算，一次网络传输</li> <li>mset：批量设置键值对</li> <li>getset key newvalue：设置一个新的value 返回旧的value</li> <li>append key value：追加value</li> <li>strlen key：返回字符串长度（注意一个中文占用两个字节）</li> <li>incrbyfloat key k 增加浮点型值</li> <li>getrange key start end 获取制定下标的所有值（截取）</li> <li>setrange key index value 设置指定下标新的值</li></ul> <p>时间复杂度 o(n)：mget、 mset、 keys 其他均为o(1)</p> <h3 id="_2-哈希-hash-small-redis"><a href="#_2-哈希-hash-small-redis" class="header-anchor">#</a> 2.哈希 hash（small redis）</h3> <h5 id="常用操作-2"><a href="#常用操作-2" class="header-anchor">#</a> 常用操作</h5> <ul><li>hset、hget、hgetall、hdel、hexists、hlen、hmget、hmset （key field value）与字符串类似</li> <li>hincrby user:1:info pageview count 自增</li> <li>hgetall：获取所有的key和values 慎重使用</li> <li>hvals:获取所有的values</li> <li>Hkeys：获取所有的keys</li></ul> <p>存储对象的三种方式：</p> <ol><li>一个键值对，key为用户唯一标示，value是用户信息json。简单，节约内存，序列化开销大，不能部分更新</li> <li>多个键值对，每个键值对为一个用户属性。 直观，可以部分更新，内存占用大，key分散</li> <li>哈希的方式存储，一个key对应多个field。直观，节约空间，部分更新，编程复杂，ttl不好控制</li></ol> <h3 id="_3-列表结构"><a href="#_3-列表结构" class="header-anchor">#</a> 3.列表结构</h3> <p>特点：有序、可重复、可以从左右插入弹出</p> <h5 id="常用操作-3"><a href="#常用操作-3" class="header-anchor">#</a> 常用操作</h5> <ul><li>rpush key val1 val2…… 从右边新增</li> <li>lpush key val1 val2…… 从左边新增</li> <li>linsert key before｜after value newvalue 在value 前/后插入newvalue</li> <li>lpop 从左边弹出</li> <li>rpop 从右边弹出</li> <li>lrem key count value
<ul><li>count=0 删除所有value相等的项</li> <li>count&gt;0 从左到右删除 count个value相等的项</li> <li>count&lt;0 从右到左删除 count个value相等的项</li></ul></li> <li>ltrim key start end 按照索引范围修剪列表 左右闭合区间。</li> <li>lrange key start end 获取指定索引范围所有item</li> <li>Lindex key index 获取指定索引的item (索引从左到右0开始，右到左-1开始)</li> <li>llen key获取长度</li> <li>lset key index newvalue 设置列表指定索引值为newvalue</li> <li>blpop/rlpop key timeout 阻塞版本 timeout是阻塞超时，0位永久阻塞 ，一旦新增则执行弹出操作（实战：微博更新时间线等）</li></ul> <h5 id="小技巧"><a href="#小技巧" class="header-anchor">#</a> 小技巧</h5> <ul><li>LPUSH + LPOP = Stack 实现栈</li> <li>LPUSH + RPOP = Queue 实现队列</li> <li>LPUSH + LTRIM = Capped Collection 控制列表大小</li> <li>LPUSH + BRPOP = Message Queue 消息队列</li></ul> <h3 id="_4-集合结构"><a href="#_4-集合结构" class="header-anchor">#</a> 4.集合结构</h3> <p>特点：无序、无重复、支持集合间操作</p> <h5 id="常用操作-4"><a href="#常用操作-4" class="header-anchor">#</a> 常用操作</h5> <p>集合内部api：</p> <ul><li>sadd key element 添加元素，已存在则添加失败 可以添加多个</li> <li>srem key element 移除元素</li> <li>scard key 计算集合中的元素</li> <li>sismember key value 判断是否在集合中存在</li> <li>srandmember key count 随机取出count个元素，不会破坏集合数据</li> <li>spop key 随机弹出一个元素</li> <li>smembers ：无序、小心使用，返回集合所有元素，可以用sscan代替使用</li> <li>实战：抽奖、点赞、踩等等</li></ul> <p>集合间api：</p> <ul><li>sdiff key1 key2 差集</li> <li>sinter key1 key2 交集</li> <li>sunion key1 key2 并集</li> <li>sdiff｜sinter｜sunion + store destkey .. 将差集、交集、并集结果保存到destkey中，实战：微博共同关注、我关注的人关注了谁等等</li> <li>SAAD 标签功能</li> <li>SPOP/SRANDMEMBER 随机抽奖功能</li> <li>SADD + SINTER 社交功能</li></ul> <h3 id="_5-有序集合"><a href="#_5-有序集合" class="header-anchor">#</a> 5.有序集合</h3> <p>组成： key ｜ score value</p> <p>特点：有序、无重复元素、值为元素+score</p> <h5 id="常用操作-5"><a href="#常用操作-5" class="header-anchor">#</a> 常用操作</h5> <ul><li>zadd key score element 新增（可以是多对，score可以重复，element不能重复）o(logN)</li> <li>zrem key element 删除 o(1)</li> <li>zscore key element 获取元素分数 o(1)</li> <li>zincrby key increScore element 分数自增 o(1)</li> <li>zcard key 获取元素个数 o(1)</li> <li>zrank key element 获取元素排名，根据score从小到大排序后的排名（从0开始）</li> <li>zrange key start end withscores 获取指定索引范围内的生序元素并打印分数 o(log(n) + m)</li> <li>zrangebyscore key minScore maxScore 通过分数范围获取 o(log(n) + m)</li> <li>zcount key minScore maxScore 获取指定分数内元素个数 o(log(n) + m)</li> <li>zremrangebyrank key start end 根据指定排名范围删除 o(log(n) + m)</li> <li>zremrangebyscore key minScore maxScore 根据指定分数范围删除 o(log(n) + m)</li> <li>zrevrank、zrevrange、zrevrangebyscore ：反向排名</li> <li>zinterstore、zunionstore 集合间的api</li> <li>实战：排行榜功能、热搜、新旧程度排名等</li></ul> <h2 id="二、常用命令"><a href="#二、常用命令" class="header-anchor">#</a> 二、常用命令</h2> <ol><li>Keys：查询所有或匹配相应的key，不推荐在生产环境使用，可以通过热备节点，在备用服务上使用，或用scan命令代替。</li> <li>Dbsize 查看键值对数量</li> <li>exists key 查看key是否存在</li> <li>expire key seconds 设置key在多少秒以后失效</li> <li>Ttl key 查看key还有多少秒失效 （-2没有key，-1没有失效时间）</li> <li>persist key 设置key不失效</li> <li>type key 查询值的类型</li></ol> <p>redis速度快的原因：</p> <ul><li>纯内存</li> <li>非IO阻塞</li> <li>避免线程切换和竞态消耗</li></ul> <h2 id="三、常用功能"><a href="#三、常用功能" class="header-anchor">#</a> 三、常用功能</h2> <h3 id="客户端使用"><a href="#客户端使用" class="header-anchor">#</a> 客户端使用：</h3> <ul><li>Java：Jedis
<ul><li>直连：Jedis jedis = new Jedis(“127.0.0.1”,6379) 使用后关闭连接</li> <li>连接池：Jedis jedis = JedisPool.getResource() 使用后归还连接</li></ul></li> <li>Python：redis-py</li></ul> <h3 id="慢查询"><a href="#慢查询" class="header-anchor">#</a> 慢查询</h3> <p>获取查询较慢的查询对列，对应配置：</p> <ul><li>slowlog-max-len 不要设置过大，默认10ms，通常设置1ms</li> <li>slowlog-log-slower-than 队列长度不要设置过小，便于查询历史数据，默认128，理解命令的生命周期，定期持久化慢查询，记录历史操作</li></ul> <h3 id="pipeline"><a href="#pipeline" class="header-anchor">#</a> PipeLine</h3> <p>​		批量打包命令，1次网络 + n次命令，非原子操作，Redis命令时间很快，pipeline就是控制网络时间，注意每次携带的数量，每次只能作用在一个redis节点。</p> <h3 id="发布订阅"><a href="#发布订阅" class="header-anchor">#</a> 发布订阅</h3> <p>​		不能读取历史发布的消息</p> <ul><li>publish channel message 发布消息 返回订阅数</li> <li>[un]subscribe channel 订阅/取消订阅一个或多个频道</li></ul> <h3 id="消息队列"><a href="#消息队列" class="header-anchor">#</a> 消息队列</h3> <p>发布一个消息只有一个订阅者能获取到，只是利用list模拟消息队列功能 。</p> <h3 id="位图bitmap"><a href="#位图bitmap" class="header-anchor">#</a> 位图bitmap</h3> <ul><li>setbit key offset value 给位图指定索引设置值</li> <li>getbit key offset 获取位图指定索引的值</li> <li>bitcount key [start end] 获取指定范围值为1的个数</li> <li>bitop op destkey key [key…] 做多个bitmap的and（交集）、or（并集）、not（非）、xor（异或）等操作并将结果保存到destkey中</li> <li>bitpos key targetBit [start][end] 计算位图指定范围第一个偏移量对应的值等于targetBit的位置</li></ul> <p>本身是string 最大512M，使用时注意setbit时的偏移量，可能出现较大的耗时</p> <div class="language- extra-class"><pre class="language-text"><code>对比 set 和 bitmap  假设 1亿用户数
Set     每个userid占用32位（假设是整型） 5000万日活用户  全部存储200MB   10万日活用户  4MB
Bitmap  每个用户占1位                  1亿全部存储         12.5MB               
</code></pre></div><h3 id="hyperloglog"><a href="#hyperloglog" class="header-anchor">#</a> hyperLogLog</h3> <p>极小的空间完成独立数量统计，本质是string ，不能重复</p> <ul><li>pfadd key element … 添加元素</li> <li>pfcount key [key…] 计算hyperLogLog中独立数据的总数</li> <li>pfmerge destkey sourcekey [sourcekey…] 合并多个hyperLogLog</li> <li>百万独立数据 15kb左右</li> <li>错误率 0.81%</li> <li>不能取出单条数据</li></ul> <h3 id="geo-地理位置"><a href="#geo-地理位置" class="header-anchor">#</a> GEO 地理位置</h3> <p>类型为zset</p> <ul><li>geoadd key longitude latitude member [….] 添加经纬度信息</li> <li>geopos key member […] 获取地理位置信息</li> <li>geodist key member1 member2 [unit] 获取两个位置的距离 unit:m、km、mi英里、ft尺</li> <li>Georadius 获取指定位置范围内的地理位置信息集合</li></ul> <h2 id="四、缓存"><a href="#四、缓存" class="header-anchor">#</a> 四、缓存</h2> <h3 id="_1-缓存的收益与成本"><a href="#_1-缓存的收益与成本" class="header-anchor">#</a> 1.缓存的收益与成本</h3> <ul><li>收益：
<ul><li>加速读写</li> <li>降低后端负载：业务段通过使用redis降低后端数据库的负载</li></ul></li> <li>成本：
<ul><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</li> <li>代码维护成本：多了一层缓存逻辑</li> <li>运维成本：例如redis cluster</li></ul></li></ul> <h3 id="_2-缓存的使用场景"><a href="#_2-缓存的使用场景" class="header-anchor">#</a> 2.缓存的使用场景</h3> <ul><li>降低后端负载：对高消耗的sql，join结果集/分组统计结果缓存</li> <li>加速请求响应时间：利用redis/memcache 优化IO响应时间</li> <li>大量写合并为批量写：如计数器先redis累加再批量写db</li></ul> <h3 id="_3-缓存更新策略"><a href="#_3-缓存更新策略" class="header-anchor">#</a> 3.缓存更新策略</h3> <p>（1）LRU/LFU/FIFO算法剔除：例如maxmemory-policy控制最大内存，一致性最差、维护成本低</p> <p>（2）超时剔除：例如expire，一致性较差、维护成本低</p> <p>（3）主动更新：开发控制生命周期，一致性较强、维护成本高</p> <p>建议：</p> <ul><li>低一致性：最大内存和淘汰策略</li> <li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</li></ul> <h3 id="_4-缓存粒度控制"><a href="#_4-缓存粒度控制" class="header-anchor">#</a> 4.缓存粒度控制</h3> <p>（1）通用性：全量属性更好</p> <p>（2）占用空间：部分属性更好</p> <p>（3）代码维护：表面上全量属性更好</p> <p>（4）实际业务中，大部分业务不需要全量属性缓存</p> <h3 id="_5-缓存穿透问题"><a href="#_5-缓存穿透问题" class="header-anchor">#</a> 5.缓存穿透问题</h3> <p>大量请求不命中缓存，直接请求存储层</p> <p>原因：</p> <ul><li>业务代码自身问题</li> <li>恶意攻击、爬虫等等，请求一些不存在的数据</li></ul> <p>如何发现：</p> <ul><li>业务的响应时间</li> <li>业务本身问题，功能问题</li> <li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul> <p>解决方法：</p> <p>（1）缓存空对象</p> <p>将缓存中不存在的数据且存储层不存在的数据，缓存空对象到缓存中</p> <p>问题：</p> <ul><li>需要更多的键。</li> <li>缓存层和存储层数据短期不一致，由于意外因素导致存储层返回空，缓存层将会存储空对象到对应键中，当意外恢复（如网络波动）时，空对象到过期时间没有到时，会出现数据不一致</li></ul> <p>（2）布隆过滤器拦截</p> <p>在缓存层之前，使用布隆过滤器拦截，需要特殊的业务场景，维护成本较高</p> <h3 id="_6-雪崩问题"><a href="#_6-雪崩问题" class="header-anchor">#</a> 6.雪崩问题</h3> <p>缓存层面高可用、客户端降级、提前演练是解决雪崩问题的重要方法</p> <h3 id="_7-无底洞问题优化"><a href="#_7-无底洞问题优化" class="header-anchor">#</a> 7.无底洞问题优化</h3> <p>问题描述：2010年，Facebook有了3000个memcache节点，加机器性能没能提升，反而下降了</p> <p>问题关键点：批量请求mget，会有更多的网络io</p> <ul><li>更多的机器不等于更高的性能</li> <li>批量接口需求（mget、mset等）</li> <li>数据增长与水平扩展需求</li></ul> <p><strong>优化IO的几种方法：</strong></p> <ol><li>命令本身优化：例如慢查询keys、hgetall bigkey</li> <li>减少网络通信次数</li> <li>降低接入成本：例如客户端长连接/链接池、NIO等</li> <li>批量操作优化可以看上一章笔记</li></ol> <h3 id="_8-热点key重建优化"><a href="#_8-热点key重建优化" class="header-anchor">#</a> 8.热点key重建优化</h3> <p>问题描述：热点key + 较长的重建时间 + 高并发</p> <p>三个目标：</p> <ul><li>减少重缓存的次数</li> <li>数据尽可能一致</li> <li>减少潜在危险</li></ul> <p>两个解决方案：</p> <p>（1）互斥锁：减少了重缓存的次数，</p> <p>​		优点：思路简单，保证一致性</p> <p>​		缺点：代码复杂，存在死锁的风险</p> <p>（2）永不过期：缓存层面不设置过期时间，在value中设置逻辑过期时间，当发现逻辑过期时间过期时间到期时，使用异步的线程执行更新热点数据操作</p> <p>​		优点：基本杜绝热点key重建问题</p> <p>​		缺点：不保证一致性，逻辑过期时间增加维护成本和内存成本</p> <p>​		建议逻辑过期时间比预想的过期时间提前一些，给出更新热点key的操作时间</p> <h2 id="五、持久化"><a href="#五、持久化" class="header-anchor">#</a> 五、持久化</h2> <p>Redis 持久化：所有的数据保持在内存中，对数据的更新将异步的保存到磁盘上</p> <p>常用的持久化方式：</p> <ul><li>快照：mysql dump 、redis RDB</li> <li>写日志： mysql binlog、hbase HLog、 redis AOF</li></ul> <h3 id="_1-rdb"><a href="#_1-rdb" class="header-anchor">#</a> 1.RDB</h3> <p>在指定的时间间隔能对你的数据进行快照存储，以二进制形式保存在硬盘上，用于备份、数据恢复等。</p> <h4 id="_1-触发方式"><a href="#_1-触发方式" class="header-anchor">#</a> （1）触发方式</h4> <ol><li><p>save（同步） 容易阻塞，生成临时文件，执行完成后会替换旧的文件，不会消耗额外内存</p></li> <li><p>bgsave（异步） 调用linux fork()函数，如果fork执行慢，依旧会阻塞redis，但大部分执行很快，fork会调用子线程执行RDB操作，消耗额外内存</p></li> <li><p>自动 通过配置，满足任意条件 生成rdb文件，可以自定义修改，不建议使用</p> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 900s内如果有1条是写入命令，就触发产生一次快照</span>
<span class="token attr-name">save</span> <span class="token attr-value">900s 1条 </span>
<span class="token comment"># 300s内如果有10条是写入命令，就触发产生一次快照</span>
<span class="token attr-name">save</span> <span class="token attr-value">300s 10条</span>
<span class="token comment"># 60s内如果有10000条是写入命令，就触发产生一次快照</span>
<span class="token attr-name">save</span> <span class="token attr-value">60s  10000条</span>
</code></pre></div></li></ol> <h4 id="_2-配置策略"><a href="#_2-配置策略" class="header-anchor">#</a> （2）配置策略</h4> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 持久化rdb文件名</span>
<span class="token attr-name">dbfilename</span> <span class="token attr-value">dump-${port}.rdb  </span>
<span class="token comment"># rdb存储当前目录，建议放到大存储磁盘下</span>
<span class="token attr-name">dir</span> <span class="token attr-value">./</span>
<span class="token comment"># 有问题停止</span>
<span class="token attr-name">Stop-writes-on-bgsave-error</span> <span class="token attr-value">yes</span>
<span class="token comment"># 压缩配置开启</span>
<span class="token attr-name">Rdbcompression</span> <span class="token attr-value">yes</span>
<span class="token comment"># 导入时是否检查</span>
<span class="token attr-name">rdbchecksum</span> <span class="token attr-value">yes</span>
</code></pre></div><h4 id="_3-触发机制"><a href="#_3-触发机制" class="header-anchor">#</a> （3）触发机制</h4> <ol><li>全量复制， 主从备份时会出发rdb生成</li> <li>debug reload 重启不清空内存，触发rdb生成</li> <li>shutdown 会触发rdb生成</li></ol> <h4 id="_4-存在问题"><a href="#_4-存在问题" class="header-anchor">#</a> （4）存在问题</h4> <ol><li>耗时、耗性能 fork()消耗内存</li> <li>不可控、容易丢失数据，宕机不可控</li></ol> <h3 id="_2-aof重写"><a href="#_2-aof重写" class="header-anchor">#</a> 2.AOF重写</h3> <p>以日志的形式将写入命令保存到AOF文件中，记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p> <p>AOF重写作用：减少磁盘占用量、加快恢复速度</p> <h4 id="_1-三种策略"><a href="#_1-三种策略" class="header-anchor">#</a> （1）三种策略</h4> <ul><li>always：写命令刷新到硬盘缓冲区，每条命令fsync到硬盘AOF文件，不丢失数据，但是io开销大</li> <li>everysec：每秒把缓冲区fsync到硬盘，可能丢失1秒数据</li> <li>no：根据操作系统决定什么时候刷新AOF文件，不可控，</li></ul> <h4 id="_2-重写的实现方式"><a href="#_2-重写的实现方式" class="header-anchor">#</a> （2）重写的实现方式：</h4> <ol><li><p>bgrewriteaof：异步执行，fork子进程，对redis数据回溯、重写到AOF文件</p></li> <li><p>AOF重写的配置：</p> <ul><li><p>auto-aof-rewrite-min-size 重写需要的尺寸</p></li> <li><p>auto-aof-rewrite-percentage 文件增长率</p></li></ul></li></ol> <p>同时满足时，自动触发aof重写，两种方式本质都是执行 bgrewriteaof，异步执行</p> <h4 id="_3-配置策略"><a href="#_3-配置策略" class="header-anchor">#</a> （3）配置策略</h4> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 打开aof功能</span>
<span class="token attr-name">appendonly</span> <span class="token attr-value">yes </span>
<span class="token comment"># 持久化aof文件名</span>
<span class="token attr-name">appendfilename</span> <span class="token attr-value">“appendonly-${port}.aof”</span>
<span class="token comment"># 同步方式</span>
<span class="token attr-name">appendfsync</span> <span class="token attr-value">everysec</span>
<span class="token comment"># aof重写期间是否同步</span>
<span class="token attr-name">no-appendfsync-on-rewrite</span> <span class="token attr-value">no</span>
<span class="token comment"># aof存储当前目录，建议放到大存储磁盘下</span>
<span class="token attr-name">dir</span> <span class="token attr-value">./</span>
<span class="token comment"># 重写触发配置</span>
<span class="token attr-name">auto-aof-rewrite-percentage</span> <span class="token attr-value">100</span>
<span class="token attr-name">auto-aof-rewrite-min-size</span> <span class="token attr-value">64mb</span>
<span class="token comment"># 加载aof时如果有错如何处理</span>
<span class="token attr-name">aof-load-truncated</span> <span class="token attr-value">yes</span>
<span class="token comment"># 文件重写策略</span>
<span class="token attr-name">aof-rewrite-incremental-fsync</span> <span class="token attr-value">yes</span>
</code></pre></div><h3 id="_3-对比rdb和aof"><a href="#_3-对比rdb和aof" class="header-anchor">#</a> 3.对比RDB和AOF</h3> <table><thead><tr><th></th> <th>RDB</th> <th>AOF</th></tr></thead> <tbody><tr><td>启动优先级</td> <td>低</td> <td>高</td></tr> <tr><td>体积</td> <td>小</td> <td>大</td></tr> <tr><td>恢复速度</td> <td>快</td> <td>慢</td></tr> <tr><td>数据安全性</td> <td>丢数据</td> <td>根据策略决定</td></tr> <tr><td>轻重</td> <td>重（计算密集）</td> <td>轻（日志追加）</td></tr></tbody></table> <p>RDB最佳策略： 建议关闭，集中管理，大量级的数据备份，可以主从部署时，从节点打开，根据实际需求制定。</p> <p>AOF策略：建议开启，有内存开销，如果仅把redis当作缓存，对数据库压力不大可以关掉。重写AOF集中管理。建议每秒刷盘</p> <p>AOF最佳策略：小分片的缓存或存储，监控硬盘、内存、负载、网络，足够的内存余负</p> <h3 id="_4-持久化常见的运维问题"><a href="#_4-持久化常见的运维问题" class="header-anchor">#</a> 4.持久化常见的运维问题</h3> <h4 id="_1-fork操作"><a href="#_1-fork操作" class="header-anchor">#</a> （1）fork操作</h4> <p>同步操作，与内存量息息相关，fork执行过慢时会引起redis主线程阻塞，当超过超时时间时，会引起程序超时。</p> <p>查持久化的执行时间，info：lastest_fork_usec</p> <p>改善fork：</p> <ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li> <li>控制redis实例最大可用内存：maxmemory</li> <li>合理配置linux内存分配策略：vm.overcommit_memory=1</li> <li>降低fork频率：例如放宽AOF重写自动触发时机，不必要的全量复制</li></ul> <h4 id="_2-进程外开销"><a href="#_2-进程外开销" class="header-anchor">#</a> （2）进程外开销</h4> <p>子进程开销：</p> <ul><li>CPU：RDB和AOF文件生成，属于CPU密集型
<ul><li>优化：不做CPU绑定，不和CPU密集型的一些应用部署在一起，单机部署不要大量重写或bgsave</li></ul></li> <li>内存：fork内存开销，copy-on-write
<ul><li>优化：单机部署不要大量重写或bgsave，echo never &gt; /sys/kernel/mm/transparet_hugepage/enabled</li></ul></li> <li>硬盘：AOF和RDB文件写入，可以结合iostat，iotop工具解析
<ul><li>优化：不要与高硬盘负载服务部署一起：存储服务、消息队列等，配置no-appendfsync-on-rewrite = yes，根据写入量决定磁盘类型是否用ssd，单机多实例持久化文件目录可以考虑分盘写入。</li></ul></li></ul> <h4 id="_3-aof追加阻塞"><a href="#_3-aof追加阻塞" class="header-anchor">#</a> （3）AOF追加阻塞</h4> <p>​		通常每秒刷盘，主线程写入AOF缓冲区，同步线程负责每秒同步刷盘操作，记录同步时间，主线程会对比上次的同步时间，如果大于2秒，则会阻塞，小于两秒则通过。这种刷盘策略可能会丢失两秒数据。</p> <p>定位主线程阻塞的方式：</p> <ul><li>redis日志 async AOF too long……</li> <li>命令行 info persistence -&gt; aof_delayed_fsync:100 (这个次数是累加的过程，需要记录后差值计算)</li> <li>top命令查看IO资源是否紧张</li></ul> <h4 id="_4-单机多实例部署"><a href="#_4-单机多实例部署" class="header-anchor">#</a> （4）单机多实例部署</h4> <h2 id="六、复制"><a href="#六、复制" class="header-anchor">#</a> 六、复制</h2> <h3 id="主从复制"><a href="#主从复制" class="header-anchor">#</a> 主从复制</h3> <p>主从复制不能做到自动故障转移</p> <p>主从复制的作用 依赖rdb文件bgsave,无论rdb配置是否开启，主从复制时依旧会启用</p> <p>（1）数据副本，高可用、分布式的基础</p> <p>（2）扩展读性能，读写分离</p> <p>一个master可以有多个slave，一个slave只有一个master，数据流向是单向的：master-&gt;slave</p> <p>实现：</p> <ul><li>命令：slaveof ip port 无需重启，但不便于管理</li> <li>配置：slaveof ip port |  slave-read-only yes(从节点只能读不能写)  统一配置，需要重启</li></ul> <p>run_id 是一个标示，重启或者有其他变化而导致runid变化时，从节点会进行全量复制的操作</p> <p>偏移量offset：当主从的偏移量过大时，表示主从复制的内容有问题</p> <h3 id="_1-全量复制"><a href="#_1-全量复制" class="header-anchor">#</a> 1.全量复制</h3> <h4 id="过程"><a href="#过程" class="header-anchor">#</a> 过程</h4> <p>（1）slave/repl -&gt; master (执行psync，参数是run_id和偏移量，主节点会把偏移量之后的数据复制给从节点，第一次执行是，可以传递 ？和-1 ，表示从主节点进行全量复制)</p> <p>（2）master -&gt; slave/repl (全量复制时，会返回runid和偏移量是多少)</p> <p>（3）slave/repl节点会保存master的基本信息</p> <p>（4）master会执行bgsave操作，生成rdb文件，发送给从节点</p> <p>（5）同时主节点会将最新的数据记录到 repl_back_buffer缓冲区（默认1M），发送完rdb文件后，将缓冲区中的buffer发给slave/repl节点</p> <p>（6）slave/repl节点会清除自己的原有数据，加载rdb文件以及buffer数据完成全量同步复制的功能</p> <h4 id="开销"><a href="#开销" class="header-anchor">#</a> 开销</h4> <p>（1）master节点的bgsave操作时间</p> <p>（2）rdb文件的网络传输时间</p> <p>（3）slave/repl节点清空数据时间</p> <p>（4）slave/repl加载rdb文件以及buffer数据的时间</p> <p>（5）可能存在的AOF重写时间（AOF开启的情况下）</p> <h3 id="_2-部分复制"><a href="#_2-部分复制" class="header-anchor">#</a> 2.部分复制</h3> <p>当网络出现波动的时候，master节点更新数据会丢失，slave/repl节点获取不到，如果在进行全量复制，会占用过多的资源。</p> <ol><li>slave/repl -&gt; master Connection lost</li> <li>master 将新的数据写入缓冲区 repl_back_buffer 默认大小1M</li> <li>slave/repl -&gt; masterConnecting to master</li> <li>slave/repl -&gt; master 执行psync {offset}{runid}</li> <li>master -&gt; slave/repl 当偏移量在buffer偏移量队列范围内，会返回continue，将buffer数据返回，实现部分复制的功能，当偏移量不在buffer的范围内时，表示丢失了很多数据，可以执行全量复制操作</li></ol> <h3 id="_3-常见问题"><a href="#_3-常见问题" class="header-anchor">#</a> 3.常见问题</h3> <h4 id="_1-读写分离"><a href="#_1-读写分离" class="header-anchor">#</a> （1）读写分离</h4> <p>读流量分摊到从节点，减少master压力，首先考虑优化master节点</p> <p>可能遇到的问题：</p> <ul><li>复制数据延迟，slave发生阻塞时，可能会发生读写不一致的情况，可以监控偏移量，不一致的时候可以切换到master节点</li> <li>读到过期数据，slave没有删除数据权限，master过期数据删除延迟，3.2版本以后已经优化了这个问题</li> <li>从节点故障，怎么将从节点迁移，成本非常高</li></ul> <h4 id="_2-主从配置不一致"><a href="#_2-主从配置不一致" class="header-anchor">#</a> （2）主从配置不一致</h4> <ul><li>例如maxmemory不一致：丢失数据。会触发最大内存的策略，淘汰数据（例如过期数据）</li> <li>例如数据结构优化参数（例如hash-max-ziplist-entries）:内存不一致</li> <li>尽量规避主从配置不一致</li></ul> <h4 id="_3-规避全量复制"><a href="#_3-规避全量复制" class="header-anchor">#</a> （3）规避全量复制</h4> <ul><li><p>第一次全量复制不可避免：小主节点、低峰时处理，数据分片，maxmemory不要过大</p></li> <li><p>节点运行id不匹配：主节点重启，runid会变，从节点会全量复制。使用故障转移的方式处理</p></li> <li><p>复制积压缓冲区不足，当出现网络波动或中断时，恢复时偏移量不在缓冲区队列内时，部分复制无法满足，会全量复制，可以通过设置增大复制缓冲区配置 rel_bcaklog_size.</p></li></ul> <h4 id="_4-规避复制风暴"><a href="#_4-规避复制风暴" class="header-anchor">#</a> （4）规避复制风暴</h4> <p>​	Master节点宕机后重启 runid发生改变，所有的slave/repl节点都会进行全量复制，对于master的开销非常大（cpu、内存、带宽等等），可以通过更换复制拓扑，减轻master负担，这种解决方式问题较多</p> <h2 id="七、redis-sentinel"><a href="#七、redis-sentinel" class="header-anchor">#</a> 七、Redis Sentinel</h2> <h3 id="_1-主从复制问题"><a href="#_1-主从复制问题" class="header-anchor">#</a> 1.主从复制问题</h3> <p>手动故障转移、写能力和存储能力受限</p> <h3 id="_2-redis-sentinel"><a href="#_2-redis-sentinel" class="header-anchor">#</a> 2.Redis Sentinel</h3> <ul><li>redis sentinel会对master和slave/repl节点进行监控，客户端从sentinel获取数据</li> <li>故障转移：
<ul><li>多个sentinel发现并确认master有问题</li> <li>选举出一个sentinel作为领导</li> <li>选出一个slave/repl作为master</li> <li>通知其余的slave/repl成为新的master的slave</li> <li>通知客户端主从变化</li> <li>等待老的master复活成为新的master节点的slave/repl节点</li></ul></li> <li>一套sentinel可以监控多个主从节点，使用master-name进行配置</li></ul> <h3 id="_3-安装与配置"><a href="#_3-安装与配置" class="header-anchor">#</a> 3.安装与配置</h3> <ul><li>配置开启主从节点</li> <li>配置开启sentinel监控主节点（sentinel是特殊的redis）</li> <li>实际应该多机器</li> <li>详细配置节点（默认端口是26379）</li></ul> <p>sentinel主要配置:</p> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"> # 端口</span>
<span class="token attr-name"> port</span> <span class="token attr-value">${port}</span>
<span class="token comment"> # 文件夹位置</span>
<span class="token attr-name"> dir</span> <span class="token attr-value">&quot;/xx/xx/xx&quot;</span>
<span class="token comment"> # 日志</span>
<span class="token attr-name"> logfile</span> <span class="token attr-value">“xx.log”</span>
<span class="token comment"> # n表示有n个sentinel发现故障后，执行故障转移操作</span>
<span class="token attr-name"> sentinel</span> <span class="token attr-value">monitor xx ip port n</span>
<span class="token comment"> # ping 30秒后不通后认为master有问题</span>
<span class="token attr-name"> sentinel</span> <span class="token attr-value">down-after-milliseconds xx 30000 </span>
<span class="token comment"> # 每次只能复制一个slave/repl节点</span>
<span class="token attr-name"> sentinel</span> <span class="token attr-value">parallel-syncs xx 1</span>
<span class="token comment"> # 故障转移时间</span>
<span class="token attr-name"> sentinel</span> <span class="token attr-value">failover-timeout xx 180000</span>
</code></pre></div><p>服务端高可用和客户端高可用：</p> <p>服务端：故障自动转移，master宕机，转移到slave后</p> <p>客户端：</p> <ol><li>遍历sentinel节点，获取一个可用的sentinel节点 + masterName</li> <li>sentinel get-master-addr-by-name masterName 获取节点信息</li> <li>role命令 验证master节点</li> <li>sentinel 对客户端 进行redis数据节点的变化通知</li></ol> <p>接入流程：</p> <ol><li>Sentinel地址集合</li> <li>masterName</li> <li>不是代理模式</li></ol> <h3 id="_4-使用jedis操作sentinel"><a href="#_4-使用jedis操作sentinel" class="header-anchor">#</a> 4.使用jedis操作sentinel：</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">JedisSentinelPool</span> sentinel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisSentinelPool</span><span class="token punctuation">(</span>masterName<span class="token punctuation">,</span>sentinelSet<span class="token punctuation">,</span>poolConfig<span class="token punctuation">,</span>timeout<span class="token punctuation">)</span>
<span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> sentinel<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_5-三个定时任务"><a href="#_5-三个定时任务" class="header-anchor">#</a> 5.三个定时任务</h3> <ol><li>每10秒每个sentinel 对master和slave执行info：发现slave节点，确认主从关系</li> <li>每2秒每个sentinel通过master节点的channel交换信息(发布订阅模式)， 通过_sentinel _:hello频道交互，交互主要作用是对节点的看法和自身信息</li> <li>每1秒每个sentinel对其他sentinel和redis执行ping操作：心跳检测的过程，失败判定的依据</li></ol> <h3 id="_6-主观下线和客观下线"><a href="#_6-主观下线和客观下线" class="header-anchor">#</a> 6.主观下线和客观下线</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># quorum表示有quorum个sentinel发现故障后，执行故障转移操作</span>
<span class="token attr-name">sentinel</span> <span class="token attr-value">monitor &lt;masterName&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span>
<span class="token comment"># sentinel定时任务每1秒对redis执行ping操作失败 30秒不通后认为master有问题 </span>
<span class="token attr-name">sentinel</span> <span class="token attr-value">down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;</span>
</code></pre></div><p>主观下线：其中一个sentinel节点对redis节点ping失败，认为其有问题</p> <p>客观下线：其中一个sentinel节点发现redis节点ping失败后，通过定时任务(2)告诉其他sentinel节 点，其他节点会通过sentinel is-master-down-by-addr masterName 去判定改节点是否失效，当认为其失效的sentinel数超过 quorun时，则判定master客观下线，然后进行故障转移的相关操作。slave/repl节点不需要客观下线，不需要故障转移。quorum常设置为 1/2+1</p> <h3 id="_7-sentinel领导者选举"><a href="#_7-sentinel领导者选举" class="header-anchor">#</a> 7.sentinel领导者选举</h3> <p>原因：只有一个sentinel节点完成故障转移</p> <p>选举：通过 sentinel is-master-down-by-addr命令都希望成为领导者</p> <ul><li>每个做主观下线的sentinel节点向其他sentinel节点发送命令，要求将它设置为领导者。</li> <li>收到命令的sentinel节点如果没有同意通过其他sentinel节点发送的命令，则同意该请求，否则拒绝</li> <li>当前的sentinel节点发现自己的票数已经超过sentinel集合的半数且超过quorum，则成为领导者</li> <li>如果此过程有多个sentinel节点成为了领导者，则将等待一段时间重新进行选举</li></ul> <h3 id="_8-故障转移"><a href="#_8-故障转移" class="header-anchor">#</a> 8.故障转移</h3> <ol><li>从slave/repl节点中选出一个“合适的”节点作为新的master节点</li> <li>对上述slave节点执行slaveof no one 命令让其成为master节点</li> <li>向剩余的slave节点发送命令，让它们成为新master的slave节点，复制规则和parallel-syncs参数有关，希望有几个slave节点同时去复制master节点数据</li> <li>更新对原来的master节点配置为slave并保持关注，当期恢复后命令它去复制新的master节点</li></ol> <h3 id="_9-故障转移时选择slave节点"><a href="#_9-故障转移时选择slave节点" class="header-anchor">#</a> 9.故障转移时选择slave节点</h3> <ol><li>选择slave-priority（slave节点优先级）最高的slave节点，如果存在则返回，不存在继续</li> <li>选择复制偏移量最大的slave节点（复制的最完整），如果存在则返回，不存在则继续</li> <li>选择runid最小的slave节点</li></ol> <h3 id="_10-常见的运维问题"><a href="#_10-常见的运维问题" class="header-anchor">#</a> 10.常见的运维问题</h3> <p>​	节点运维：主节点、从节点、sentinel节点</p> <p>​	节点下线：机器下线、机器性能不足（cpu、内存、硬盘、网络）、节点自身故障，下线时考虑是否要做清理工作，从节点考虑读写分离情况</p> <p>​	节点上线：主节点上线 sentinel failover进行替换，从节点上线 slaveof即可，sentinel可以感知</p> <h3 id="_11-高可用读写分离"><a href="#_11-高可用读写分离" class="header-anchor">#</a> 11.高可用读写分离</h3> <p>从节点作用：</p> <ul><li>副本：高可用的基础</li> <li>扩展：读能力</li></ul> <p>客户端需要知道的三个消息：</p> <ul><li>switch-master：切换主节点（从节点晋升）</li> <li>convert-to-slave：切换从节点（原主降为从）</li> <li>sdown：主观下线</li></ul> <h3 id="_12-总结"><a href="#_12-总结" class="header-anchor">#</a> 12.总结</h3> <ol><li>Redis Sentinel通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控</li> <li>Redis Sentinel在对节点做失败判定时分为主观下线和客观下线</li> <li>理解Redis Sentinel故障转移日志</li> <li>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化</li></ol> <h2 id="八、redis-cluster"><a href="#八、redis-cluster" class="header-anchor">#</a> 八、Redis Cluster</h2> <p>使用集群的原因：</p> <ul><li>并发量</li> <li>数据量</li></ul> <h3 id="_1-数据分布"><a href="#_1-数据分布" class="header-anchor">#</a> 1.数据分布</h3> <p>数据分区：</p> <ul><li>顺序分区</li> <li>哈希分区</li></ul> <p>特点：</p> <ul><li>顺序分批：数据分散度易倾斜、键值业务相关、顺序访问</li> <li>哈希分布：数据分散度高、键值分布业务无关、无法顺序访问、支持批量操作</li></ul> <p>Redis Cluster 是哈希分区的方式</p> <h3 id="_2-节点取余分区"><a href="#_2-节点取余分区" class="header-anchor">#</a> 2.节点取余分区</h3> <p>hash（key）%nodes 一般不建议使用</p> <p>优势：简单易懂</p> <p>缺点：节点伸缩时，数据迁移量非常大（80%左右），迁移数量和添加节点数量有关：建议多倍扩容（50%） 重新分配数据，需要从数据库重新load ，回写缓存，开销较大</p> <h3 id="_3-一致性哈希"><a href="#_3-一致性哈希" class="header-anchor">#</a> 3.一致性哈希</h3> <p>​		设定token=0～2的32次方，为每个节点分配token值，负责一部分的token范围，通过对key进行hash计算token结果，顺时针的寻找第一个遇到的节点，数据就会存到该节点，节点伸缩的时候只影响临近的节点，但是仍然有数据迁移，所以只能在缓存的场景下使用，建议多倍扩容来保证最小迁移数据和负载均衡。</p> <h3 id="_4-虚拟槽分区"><a href="#_4-虚拟槽分区" class="header-anchor">#</a> 4.虚拟槽分区</h3> <p>redis cluster使用的方式：16384个槽</p> <ul><li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li> <li>良好的哈希函数：如CRC16。 keyhash = hash(key) slot(槽) = keyhash%16383</li> <li>服务端管理节点、槽、数据的关系</li></ul> <h3 id="_5-redis-cluster"><a href="#_5-redis-cluster" class="header-anchor">#</a> 5.Redis Cluster</h3> <p>分布式架构：节点之间是互相通信的，每个节点都负责读写。</p> <p>Redis Cluster：节点、节点之间的meet操作（gossip协议）、指派槽、复制</p> <p>特点：主从复制、高可用、分片</p> <h3 id="_6-安装"><a href="#_6-安装" class="header-anchor">#</a> 6.安装</h3> <h4 id="_1-原声命令安装"><a href="#_1-原声命令安装" class="header-anchor">#</a> （1）原声命令安装：</h4> <p>生产环境不使用，可以用开理解cluster架构原理</p> <ol><li><p>配置节点开启</p> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 端口</span>
<span class="token attr-name">port</span> <span class="token attr-value">${}</span>
<span class="token comment"># 守护线程</span>
<span class="token attr-name">daemonize</span> <span class="token attr-value">yes</span>
<span class="token comment"># 文件位置</span>
<span class="token attr-name">dir</span> <span class="token attr-value">&quot;/xx/xx/xx/xx&quot;</span>
<span class="token comment"># rdb文件名</span>
<span class="token attr-name">dbfilename</span> <span class="token attr-value">&quot;dump-${port}.rdb&quot;</span>
<span class="token comment"># 日志文件</span>
<span class="token attr-name">logfile</span> <span class="token attr-value">“${port}.log”</span>
<span class="token comment"># cluster节点配置</span>
<span class="token attr-name">cluster-enabled</span> <span class="token attr-value">yes</span>
<span class="token comment"># 集群配置文件</span>
<span class="token attr-name">cluster-config-file</span> <span class="token attr-value">nodes-${port}.conf</span>
<span class="token comment"># 主观下线的超时时间</span>
<span class="token attr-name">cluster-node-timeout</span> <span class="token attr-value">15000 </span>
<span class="token comment"># 当有一个节点不可用则不对外服务</span>
<span class="token attr-name">cluster-require-full-coverage</span> <span class="token attr-value">yes/no </span>
</code></pre></div></li> <li><p>meet</p> <p>cluster meet ip port</p></li> <li><p>指派槽</p> <div class="language-shell extra-class"><pre class="language-shell"><code>cluster addslots slot <span class="token punctuation">[</span>slot…<span class="token punctuation">]</span>  //例如<span class="token punctuation">{</span><span class="token number">0</span>…16383<span class="token punctuation">}</span>
// 可以通过脚本执行:
<span class="token assign-left variable">start</span><span class="token operator">=</span><span class="token variable">$1</span>
<span class="token assign-left variable">end</span><span class="token operator">=</span><span class="token variable">$2</span>
<span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token variable">$3</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">slot</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">seq</span> $<span class="token punctuation">{</span>start<span class="token punctuation">}</span> $<span class="token punctuation">{</span>end<span class="token punctuation">}</span><span class="token variable">`</span></span>
	<span class="token keyword">do</span>
		<span class="token builtin class-name">echo</span> <span class="token string">&quot;slot:<span class="token variable">${slot}</span>&quot;</span>
		redis-cli -p <span class="token variable">${port}</span> cluster addslots <span class="token variable">${slot}</span>
	<span class="token keyword">done</span>
</code></pre></div></li> <li><p>主从分配</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># (区别于runid，不会重置)</span>
cluster replicate node-id 
<span class="token comment"># 查看集群node信息</span>
cluster nodes 
</code></pre></div></li></ol> <h4 id="_2-官方工具安装"><a href="#_2-官方工具安装" class="header-anchor">#</a> （2）官方工具安装</h4> <p>ruby工具一键安装 ，高效，准确</p> <ul><li>下载、编译、安装ruby</li> <li>安装rubygem redis客户端</li> <li>安装redis-trib.rb</li></ul> <p><strong>低版本按照以上方法执行，高版本已经集成在redis-cli中</strong></p> <h4 id="_3-其他工具可视化部署"><a href="#_3-其他工具可视化部署" class="header-anchor">#</a> （3）其他工具可视化部署</h4> <h2 id="九、redis-cluster-深入理解"><a href="#九、redis-cluster-深入理解" class="header-anchor">#</a> 九、Redis Cluster 深入理解</h2> <h3 id="_1-moved重定向"><a href="#_1-moved重定向" class="header-anchor">#</a> 1.moved重定向</h3> <ul><li>客户端发送键命令时，请求任意redis节点</li> <li>redis根据计算槽点结果和对应的节点后，判断是否指向自身</li> <li>如果指向自身，则继续执行命令</li> <li>如果不是自身，回复moved命令(异常)，告诉客户端该数据在哪个节点上</li> <li>客户端重定向发送命令</li></ul> <p>当redis是以集群模式连接服务时，即redis-cli -c -p 7000 时，会自动重定向到指定的节点并执行命令。</p> <p>当不是以集群模式时，即redis-cli -p 7000时，会返回moved异常，不会自动执行重定向并执行命令。</p> <h3 id="_2-ask重定向"><a href="#_2-ask重定向" class="header-anchor">#</a> 2.ask重定向</h3> <p>由于虚拟槽从源节点正在迁移到目标节点，而客户端记录的是源节点时，就会出现ask重定向的现象</p> <ul><li>发送键命令到源节点</li> <li>源节点回复ask重定向信息</li> <li>asking并发送命令到目标节点</li> <li>目标节点相应结果</li></ul> <h3 id="_3-smart客户端实现"><a href="#_3-smart客户端实现" class="header-anchor">#</a> 3.smart客户端实现</h3> <h4 id="_1-smart客户端原理-追求性能"><a href="#_1-smart客户端原理-追求性能" class="header-anchor">#</a> （1）smart客户端原理：追求性能</h4> <ol><li>从集群中选一个可运行节点，使用cluster clots初始化槽和节点映射</li> <li>将cluster slots的结果映射到本地，为每个节点创建JedisPool</li> <li>准备执行命令</li> <li>当连接出现错误时，会随机连接一个活跃节点，返回moved异常时，重新初始化槽和节点映射缓存</li></ol> <p>不要轻易刷新本地的缓存，会影响执行效率。在出现moved重定向异常的情况下，需要刷新本地缓存</p> <h4 id="_2-jediscluster"><a href="#_2-jediscluster" class="header-anchor">#</a> （2）JedisCluster</h4> <ol><li><p>JedisCluster基本使用</p> <ul><li>单例模式：内置了所有节点的连接池</li> <li>无需手动借还链接池</li> <li>合理设置commons-pool</li></ul></li> <li><p>整合spring</p></li> <li><p>多节点命令实现</p> <ul><li>获取所有节点的jedisPool，jedisCluster.getClusterNodes() 结果是Map</li> <li>判断是否是主节点，通过info返回的结果，查看role字段的值</li></ul></li> <li><p>批量命令实现</p> <p>mget、mset必须在一个槽内</p> <p>四种优化批量的方法：</p> <ul><li><p>串行mget：遍历所有key，获取结果后汇总 n次网络时间。</p> <p>优点：简单，满足少量key的需求</p> <p>缺点：大量key请求延迟严重</p></li> <li><p>串行IO：在客户端通过计算key的hash值后，根据节点的slot范围，将key分组后通过papeline请求redis获取结果。分组节点次网络时间。</p> <p>优点：简单、少量节点满足需求</p> <p>缺点：大量节点时延迟严重</p></li> <li><p>并行IO：在串行的基础上，并行通过pipeline获取结果。1次网络时间</p> <p>优点：并行、延迟取决于最慢的节点</p> <p>缺点：复杂、超时定位难</p></li> <li><p>hash_tag：将key进行tag包装，保证所有的key都在一个redis节点上。一次网络请求。</p> <p>优点：性能最高</p> <p>缺点：读写增加tag维护成本，容易出现但节点压力过大，数据倾斜</p></li></ul></li></ol> <h3 id="_4-rediscluster故障转移"><a href="#_4-rediscluster故障转移" class="header-anchor">#</a> 4.RedisCluster故障转移</h3> <h4 id="_1-故障发现"><a href="#_1-故障发现" class="header-anchor">#</a> （1）故障发现</h4> <ol><li>通过ping/pong消息实现故障发现：不需要sentinel</li> <li>主观下线：某个节点认为另一个节点不可用 pfail状态</li> <li>客观下线：当半数以上持有槽的主节点都标记了某个节点主观下线时，尝试客观下线</li></ol> <p>尝试时，先计算有效的下线报告数量，是否大于槽节点总数的一半，大于就更新为客观下线，然后向集群广播下线节点的fail消息，通知故障节点的从节点触发故障转移流程</p> <h4 id="_2-故障恢复"><a href="#_2-故障恢复" class="header-anchor">#</a> （2）故障恢复</h4> <ol><li><p>资格检查</p> <ul><li>每个从节点检查与故障主节点的断线时间</li> <li>cluster-node-timeout* cluster-slave-validity-factor（默认15*10）</li> <li>超过上述时间则没有成为主节点的可能性</li></ul></li> <li><p>准备选举时间</p> <p>偏移量更大的，更接近与故障主节点数据一致性的从节点，准备选举时间越短小，越容易成为主节点</p></li> <li><p>选举投票</p> <p>准备选举时间结束后会使主节点发起选举，所以选举时间越短，偏移量越大，则获取投票数越多，当投票数大于N/2 +1 时，就可以替换主节点。</p></li> <li><p>替换主节点</p> <ul><li>执行slaveof no one，取消复制变为主节点</li> <li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己</li> <li>向集群广播消息，表明已经替换了故障节点</li></ul></li></ol> <h3 id="_5-常见问题"><a href="#_5-常见问题" class="header-anchor">#</a> 5.常见问题</h3> <h4 id="_1-集群的完整性"><a href="#_1-集群的完整性" class="header-anchor">#</a> （1）集群的完整性</h4> <div class="language- extra-class"><pre class="language-text"><code>配置参数cluster-require-full-coverage 默认时yes
    在部分key所在的节点不可用时，如果此参数设置为&quot;yes&quot;(默认值), 则整个集群停止接受操作；如果此参数设置为&quot;no&quot;，则集群依然为可达节点上的key提供读操作。集群中16384个槽全部可用：保证集群完整性，节点故障或故障转移时集群不可用，只针对key的操作，所以不适用于大部分的业务，建议设置为no。
</code></pre></div><h4 id="_2-带宽消耗"><a href="#_2-带宽消耗" class="header-anchor">#</a> （2）带宽消耗</h4> <p>官方建议：小于1000个节点</p> <p>影响因素：</p> <ul><li>发送消息频率：节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</li> <li>消息数据量：slots槽数组（2kb空间）和整个集群1/10的状态数据（10个节点状态数据约1kb）</li> <li>节点部署到机器规模：集群分布的机器越多且每台机器划分的节点数越均匀，则集群整体的可用带宽越高</li></ul> <p>优化：</p> <ul><li>避免大集群，避免多业务使用一个集群，可以拆分成多个集群</li> <li>cluster-node-timeout：带宽和故障转移速度的均衡</li> <li>尽量均匀分配到多机器上：保证高可用和带宽</li></ul> <h4 id="_3-pub-sub广播"><a href="#_3-pub-sub广播" class="header-anchor">#</a> （3）Pub/Sub广播</h4> <p>问题：publish在集群每个节点广播，会加重带宽消耗</p> <p>可以单独开启一套redis sentinel解决</p> <h4 id="_4-集群倾斜"><a href="#_4-集群倾斜" class="header-anchor">#</a> （4）集群倾斜</h4> <ol><li><p>数据倾斜：内存不均匀</p> <ul><li>节点和槽分配不均匀
<ul><li>查看槽和节点的信息：redis-cli --cluster info ip：port</li> <li>重新均衡分配槽(谨慎使用)：redis-cli --cluster rebalance ip:port</li></ul></li> <li>不同槽对应的键值数差异较大
<ul><li>CRC16正常情况下比较均匀</li> <li>可能存在hash_tag</li> <li>cluster countkeysinslot {slot}获取槽对应的键值个数</li></ul></li> <li>包含bigkey
<ul><li>redis-cli --bigkeys建议在从节点执行</li></ul></li> <li>内存相关配置不一致
<ul><li>ziplist、intset等配置，定期检查一致性</li></ul></li> <li>客户端缓冲区不一致等等原因很多</li></ul></li> <li><p>请求倾斜：热点数据</p> <p>热点key：重要的key或者bigkey</p> <p>优化：</p> <ul><li>避免bigkey</li> <li>热键不要使用hash_tag</li> <li>当一致性不高时，使用本地缓存+mq实现</li></ul></li></ol> <h3 id="_6-集群读写分离"><a href="#_6-集群读写分离" class="header-anchor">#</a> 6.集群读写分离</h3> <p>集群模式的从节点不接受任何的读写请求</p> <p>只读连接： 重定向到负责槽的主节点，readonly命令可以读(从节点)，</p> <p>读写分离更加复杂：需要自己实现客户端，成本很高，不建议使用。参考sentinel连接级别的命令，连接断开时需重连</p> <h3 id="_7-数据迁移-在线-离线"><a href="#_7-数据迁移-在线-离线" class="header-anchor">#</a> 7.数据迁移：在线/离线</h3> <h4 id="_1-官方迁移工具-redis-cli-cluster-import"><a href="#_1-官方迁移工具-redis-cli-cluster-import" class="header-anchor">#</a> （1）官方迁移工具：redis-cli --cluster import</h4> <ul><li>只能从单机迁移到集群</li> <li>不支持在线迁移：source需要停写，迁移时的数据不支持迁移</li> <li>不支持断点续传</li> <li>单线程迁移：影响速度</li></ul> <h4 id="_2-在线迁移-唯品会redis-migrate-tool、豌豆荚redis-port"><a href="#_2-在线迁移-唯品会redis-migrate-tool、豌豆荚redis-port" class="header-anchor">#</a> （2）在线迁移：唯品会redis-migrate-tool、豌豆荚redis-port</h4> <h3 id="_8-集群vs单机"><a href="#_8-集群vs单机" class="header-anchor">#</a> 8.集群vs单机</h3> <h4 id="_1-集群"><a href="#_1-集群" class="header-anchor">#</a> （1）集群</h4> <ul><li>key批量操作支持有限：例如mget、mset必须在一个槽内</li> <li>key事务和lua支持有限，操作的key必须在一个节点</li> <li>key是数据分区的最小粒度：不支持bigkey分区</li> <li>复制只支持一层：不支持树形复制结构</li></ul> <ol><li>RedisCluster满足容量和性能的扩展性，但是很多业务不需要。</li> <li>大多数时客户端的性能会降低。</li> <li>命令无法跨节点使用</li> <li>客户端维护更复杂：sdk和应用本身消耗，更多的连接池</li></ol> <p>RedisSentinel就已经足够大多数场景使用。</p> <h3 id="_9-总结"><a href="#_9-总结" class="header-anchor">#</a> 9.总结</h3> <ol><li>Redis cluster数据分区规则采用虚拟槽方式（16384个槽），每个节点负责一部分槽和相关数据，实现数据和请求的负载均衡。</li> <li>搭建集群划分四个步骤：准备节点，节点握手，分配槽、复制。redis-cli --cluster（低版本使用redis-trib.rb）工具快速搭建集群</li> <li>集群伸缩通过在节点之间移动槽和相关数据实现。</li> <li>使用smart客户端操作集群达到通信效率最大化，客户端内部负责计算维护键-&gt;槽-&gt;节点的映射，用于快速定位到目标节点。每种语言维护各自的客户端。</li> <li>集群自动故障转移过程分为故障发现和节点恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时，标记它为客观下线状态。从节点负责对客观下线的主节点触发故障恢复流程，保证集群的高可用性。</li> <li>常见的开发运维问题：超大规模的集群带宽消耗、pub/sub广播问题、集群倾斜问题、单机和集群的对比等。</li></ol> <h2 id="十、redis集群扩容"><a href="#十、redis集群扩容" class="header-anchor">#</a> 十、Redis集群扩容</h2> <h3 id="_1-集群伸缩"><a href="#_1-集群伸缩" class="header-anchor">#</a> 1.集群伸缩</h3> <p>原理：虚拟槽和对应的数据在节点之间的移动</p> <h3 id="_2-收缩集群"><a href="#_2-收缩集群" class="header-anchor">#</a> 2.收缩集群</h3> <ol><li><p>下线迁移槽：同扩容</p> <div class="language-shell extra-class"><pre class="language-shell"><code>redis-cli --cluster reshard --cluster-from b8ae8c6e744afd3cb7eb8cd0662ad3862f0ae921 --cluster-to d99559b0168a683bc811e80c3a684098e31bf797  --cluster-slots <span class="token number">1366</span> <span class="token number">127.0</span>.0.1:7006
</code></pre></div></li> <li><p>忘记节点：cluster forget {downNodeId}</p> <div class="language-shell extra-class"><pre class="language-shell"><code>redis-cli --cluster del-node <span class="token number">127.0</span>.0.1:7000 7bc190508cfd3027dfbd000b9ab111d97ba152c8
</code></pre></div></li> <li><p>关闭节点</p> <p>下线时，先下从节点，再下主节点，否则会触发故障转移</p></li></ol> <h3 id="_3-扩容集群"><a href="#_3-扩容集群" class="header-anchor">#</a> 3.扩容集群</h3> <ol><li>准备新节点：集群模式、配置和其他节点统一、孤立节点</li> <li>加入集群：通过cluster meet 加入集群</li> <li>迁移虚拟槽和数据</li></ol> <p>作用：</p> <ul><li>迁移槽和数据实现扩容</li> <li>作为从节点负责故障转移</li></ul> <p>使用官方工具redis-trib.rb add-node 为集群添加节点时，会检测改节点是否是孤立节点。如果新节点不是孤立节点，而是其他集群的节点时，会导致两个集群混合，影响较为严重。</p> <p>迁移虚拟槽和数据：</p> <ul><li><p>对目标节点发送：cluster setslot {slot} importing {sourceNodeId} 命令，让目标节点准备导入槽点数据</p></li> <li><p>对源节点发送：cluster setslot {slot} migrating {targetNodeId} 命令，让源节点准备迁出槽的数据</p></li> <li><p>源节点循环执行cluster getkeysinslot {slot} {count}命令，每次获取count个属于槽的键</p></li> <li><p>在源节点执行migrate {targetIp} {targetPort} key 0 {timeout} 命令把指定key迁移</p></li> <li><p>重复3、4，直到槽下所有的键数据迁移到目标节点</p></li> <li><p>向集群内所有主节点发送cluster setslot {slot} node {targetNodeId}命令，通知槽分配给目标节点</p> <img src="/csrsm-blog/img/redis/redis-数据迁移.jpg" alt="redis"></li></ul> <p>可以使用redis-cli --cluster reshard 127.0.0.1 7000 命令添加节点。</p> <p>高版本已经不使用redis-trib.rb来执行，已被redis-cli --cluster代替</p> <h2 id="十一、cachecloud"><a href="#十一、cachecloud" class="header-anchor">#</a> 十一、CacheCloud</h2> <p>问题：</p> <p>1.发布构建繁琐，私搭乱盖</p> <p>2.节点、机器等运维成本</p> <p>3.监控报警初级</p> <p>CacheCloud</p> <p>1.一键开启Redis（Standalone、Sentinel、Cluster）</p> <p>2.机器、应用、实例监控和报警</p> <p>3.客户端：透明使用、性能上报</p> <p>4.可视化运维：配置、扩容、failover、机器/应用/实例上下线</p> <p>5.已存在redis直接接入和数据迁移</p> <p>6.具体文档见http://github.com/sohutv/cachecloud</p> <p>7.运维工具，不是代理</p></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2022-05-02
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2022-05-19
    </span></section> <section class="post-links" data-v-4e23451f><a href="/csrsm-blog/posts/2022/03/28/jvm%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90.html" class="post-link" data-v-4e23451f>
      上一篇 : JVM-整体结构内存模型
    </a> <a href="/csrsm-blog/posts/2022/05/02/mysql%E4%BC%98%E5%8C%96.html" class="post-link" data-v-4e23451f>
      下一篇 : MySQL调优
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(http://img.icoisini.xyz/wx-background.jpg);" data-v-9d847660><img src="http://img.icoisini.xyz/cm.jpg" alt="小二哥" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      小二哥
    </section> <section class="info-desc" data-v-9d847660>Don`t Worry Be Happy!</section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="DaLian City, China" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>DaLian City, China</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          DaLian City, China
        </span></span></section> <section data-v-9d847660><span title="DaLian University of Technology" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>DaLian University of Technology</title><use xlink:href="#icon-organization" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          DaLian University of Technology
        </span></span></section> <section data-v-9d847660><a href="mailto:csrsming@163.com" title="csrsming@163.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>csrsming@163.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          csrsming@163.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/csrsm" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: csrsm" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: csrsm</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#一、数据类型">一、数据类型</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-字符串string">1.字符串String</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-哈希-hash-small-redis">2.哈希 hash（small redis）</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-列表结构">3.列表结构</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_4-集合结构">4.集合结构</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_5-有序集合">5.有序集合</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#二、常用命令">二、常用命令</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#三、常用功能">三、常用功能</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#客户端使用">客户端使用：</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#慢查询">慢查询</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#pipeline">PipeLine</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#发布订阅">发布订阅</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#消息队列">消息队列</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#位图bitmap">位图bitmap</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#hyperloglog">hyperLogLog</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#geo-地理位置">GEO 地理位置</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#四、缓存">四、缓存</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-缓存的收益与成本">1.缓存的收益与成本</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-缓存的使用场景">2.缓存的使用场景</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-缓存更新策略">3.缓存更新策略</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_4-缓存粒度控制">4.缓存粒度控制</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_5-缓存穿透问题">5.缓存穿透问题</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_6-雪崩问题">6.雪崩问题</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_7-无底洞问题优化">7.无底洞问题优化</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_8-热点key重建优化">8.热点key重建优化</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#五、持久化">五、持久化</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-rdb">1.RDB</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-aof重写">2.AOF重写</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-对比rdb和aof">3.对比RDB和AOF</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_4-持久化常见的运维问题">4.持久化常见的运维问题</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#六、复制">六、复制</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#主从复制">主从复制</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-全量复制">1.全量复制</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-部分复制">2.部分复制</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-常见问题">3.常见问题</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#七、redis-sentinel">七、Redis Sentinel</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-主从复制问题">1.主从复制问题</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-redis-sentinel">2.Redis Sentinel</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-安装与配置">3.安装与配置</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_4-使用jedis操作sentinel">4.使用jedis操作sentinel：</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_5-三个定时任务">5.三个定时任务</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_6-主观下线和客观下线">6.主观下线和客观下线</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_7-sentinel领导者选举">7.sentinel领导者选举</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_8-故障转移">8.故障转移</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_9-故障转移时选择slave节点">9.故障转移时选择slave节点</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_10-常见的运维问题">10.常见的运维问题</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_11-高可用读写分离">11.高可用读写分离</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_12-总结">12.总结</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#八、redis-cluster">八、Redis Cluster</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-数据分布">1.数据分布</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-节点取余分区">2.节点取余分区</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-一致性哈希">3.一致性哈希</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_4-虚拟槽分区">4.虚拟槽分区</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_5-redis-cluster">5.Redis Cluster</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_6-安装">6.安装</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#九、redis-cluster-深入理解">九、Redis Cluster 深入理解</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-moved重定向">1.moved重定向</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-ask重定向">2.ask重定向</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-smart客户端实现">3.smart客户端实现</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_4-rediscluster故障转移">4.RedisCluster故障转移</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_5-常见问题">5.常见问题</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_6-集群读写分离">6.集群读写分离</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_7-数据迁移-在线-离线">7.数据迁移：在线/离线</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_8-集群vs单机">8.集群vs单机</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_9-总结">9.总结</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#十、redis集群扩容">十、Redis集群扩容</a><ul><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_1-集群伸缩">1.集群伸缩</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_2-收缩集群">2.收缩集群</a></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#_3-扩容集群">3.扩容集群</a></li></ul></li><li><a href="/csrsm-blog/posts/2022/05/02/redis.html#十一、cachecloud">十一、CacheCloud</a></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/csrsm-blog/posts/2022/05/02/redis.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-1375e54c><p class="footer-sns-links" data-v-1375e54c><a href="https://github.com/csrsm" target="_blank" class="sns-link" data-v-1375e54c><span title="GitHub: csrsm" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>GitHub: csrsm</title><use xlink:href="#icon-github" data-v-1375e54c data-v-1375e54c></use></svg></span></a></p> <!----> <p class="footer-text" data-v-1375e54c>Copyright 2016-present <a href="https://github.com/csrsm" target="_blank">csrsm</a></p></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/csrsm-blog/assets/js/app.454ee9d8.js" defer></script><script src="/csrsm-blog/assets/js/7.dcf110ed.js" defer></script><script src="/csrsm-blog/assets/js/49.ada3dd91.js" defer></script>
  </body>
</html>
