<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>spring面试题 | Csrsm</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/post-ci/favicon.ico">
    <meta name="description" content="This is my blog">
    <link rel="preload" href="/post-ci/assets/css/0.styles.0012e2a3.css" as="style"><link rel="preload" href="/post-ci/assets/js/app.d7fff394.js" as="script"><link rel="preload" href="/post-ci/assets/js/7.8eaaf042.js" as="script"><link rel="preload" href="/post-ci/assets/js/28.8186bd22.js" as="script"><link rel="prefetch" href="/post-ci/assets/js/1.2e718cca.js"><link rel="prefetch" href="/post-ci/assets/js/10.503da5e1.js"><link rel="prefetch" href="/post-ci/assets/js/11.9d2fdfae.js"><link rel="prefetch" href="/post-ci/assets/js/12.fcb21a1d.js"><link rel="prefetch" href="/post-ci/assets/js/13.96503fd7.js"><link rel="prefetch" href="/post-ci/assets/js/14.20d93468.js"><link rel="prefetch" href="/post-ci/assets/js/15.f0e991c0.js"><link rel="prefetch" href="/post-ci/assets/js/16.f30d651c.js"><link rel="prefetch" href="/post-ci/assets/js/17.bcd8c3e0.js"><link rel="prefetch" href="/post-ci/assets/js/18.0505af28.js"><link rel="prefetch" href="/post-ci/assets/js/19.aa3ebf7b.js"><link rel="prefetch" href="/post-ci/assets/js/20.70335466.js"><link rel="prefetch" href="/post-ci/assets/js/21.0973e7c3.js"><link rel="prefetch" href="/post-ci/assets/js/22.3329f709.js"><link rel="prefetch" href="/post-ci/assets/js/23.1c2d7d48.js"><link rel="prefetch" href="/post-ci/assets/js/24.838c2ca8.js"><link rel="prefetch" href="/post-ci/assets/js/25.ae076022.js"><link rel="prefetch" href="/post-ci/assets/js/26.7c927ccc.js"><link rel="prefetch" href="/post-ci/assets/js/27.6bf58fe8.js"><link rel="prefetch" href="/post-ci/assets/js/29.a2de336c.js"><link rel="prefetch" href="/post-ci/assets/js/3.ff189134.js"><link rel="prefetch" href="/post-ci/assets/js/30.b73414a5.js"><link rel="prefetch" href="/post-ci/assets/js/31.d6f8d0f0.js"><link rel="prefetch" href="/post-ci/assets/js/32.ce08c7bb.js"><link rel="prefetch" href="/post-ci/assets/js/33.2f3e4670.js"><link rel="prefetch" href="/post-ci/assets/js/34.56499776.js"><link rel="prefetch" href="/post-ci/assets/js/35.85c56b90.js"><link rel="prefetch" href="/post-ci/assets/js/36.2aae44b6.js"><link rel="prefetch" href="/post-ci/assets/js/37.8e23ffe8.js"><link rel="prefetch" href="/post-ci/assets/js/38.b1c95985.js"><link rel="prefetch" href="/post-ci/assets/js/39.535d630a.js"><link rel="prefetch" href="/post-ci/assets/js/4.326ff035.js"><link rel="prefetch" href="/post-ci/assets/js/40.d4e8e9cb.js"><link rel="prefetch" href="/post-ci/assets/js/41.f9f3f5c4.js"><link rel="prefetch" href="/post-ci/assets/js/42.033cafdc.js"><link rel="prefetch" href="/post-ci/assets/js/43.fffd4ab5.js"><link rel="prefetch" href="/post-ci/assets/js/44.41e542d6.js"><link rel="prefetch" href="/post-ci/assets/js/45.959478c0.js"><link rel="prefetch" href="/post-ci/assets/js/46.d4d72e71.js"><link rel="prefetch" href="/post-ci/assets/js/47.28092f9f.js"><link rel="prefetch" href="/post-ci/assets/js/48.bf8df87a.js"><link rel="prefetch" href="/post-ci/assets/js/49.08c4ce42.js"><link rel="prefetch" href="/post-ci/assets/js/5.f96cd824.js"><link rel="prefetch" href="/post-ci/assets/js/50.04acac33.js"><link rel="prefetch" href="/post-ci/assets/js/51.a4814c21.js"><link rel="prefetch" href="/post-ci/assets/js/52.3f224493.js"><link rel="prefetch" href="/post-ci/assets/js/53.59ce7c4f.js"><link rel="prefetch" href="/post-ci/assets/js/54.212d0dc3.js"><link rel="prefetch" href="/post-ci/assets/js/55.06ab64ec.js"><link rel="prefetch" href="/post-ci/assets/js/56.a03dd5c9.js"><link rel="prefetch" href="/post-ci/assets/js/57.26814c66.js"><link rel="prefetch" href="/post-ci/assets/js/58.78ed4665.js"><link rel="prefetch" href="/post-ci/assets/js/59.e34eeb11.js"><link rel="prefetch" href="/post-ci/assets/js/6.562b2ef1.js"><link rel="prefetch" href="/post-ci/assets/js/60.c4b35501.js"><link rel="prefetch" href="/post-ci/assets/js/8.40f58b51.js"><link rel="prefetch" href="/post-ci/assets/js/9.c8fcfbba.js">
    <link rel="stylesheet" href="/post-ci/assets/css/0.styles.0012e2a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(http://img.icoisini.xyz/background.jpg);" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/post-ci/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          Csrsm
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/post-ci/" class="navbar-link" data-v-e4145d0a>
            首页
          </a><a href="/post-ci/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            Csrsm
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          spring面试题
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2022-12-02
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2023-04-09
    </span></section> <section class="post-links" data-v-4e23451f><a href="/post-ci/posts/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html" class="post-link" data-v-4e23451f>
      上一篇 : 微服务
    </a> <a href="/post-ci/posts/2022/12/02/jvm%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html" class="post-link" data-v-4e23451f>
      下一篇 : jvm面试题
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><h2 id="_1-谈谈对spring-ioc的理解-原理和实现"><a href="#_1-谈谈对spring-ioc的理解-原理和实现" class="header-anchor">#</a> 1.谈谈对Spring IOC的理解，原理和实现？</h2> <p>总分总结构回答问题，分为两种思路</p> <h6 id="_1-总体介绍"><a href="#_1-总体介绍" class="header-anchor">#</a> （1）总体介绍：</h6> <ul><li>ioc即Inversion of Control，控制反转，是一种理论思想，传统的对象是由使用者来控制，而有了spring后，可以把整个对象交给spring来进行管理，这是spring的核心。</li> <li>spring是一个容器，可以存储对象，使用map结构来存储，在spring中一般存在三级缓存，其中singletonObjects中存放完整的对象</li> <li>整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理（bean的生命周期）</li></ul> <h6 id="_2-分"><a href="#_2-分" class="header-anchor">#</a> （2）分</h6> <p>spring中的bean都是通过反射的方式生成的。同时其中包含的很多扩展点，比如最常用的对BeanFactory的扩展，对bean的扩展（对占位符${}的处理），除此之外，ioc中最核心的就是填充具体bean的属性，和生命周期。</p> <h2 id="_2-谈一下spring-ioc的底层实现"><a href="#_2-谈一下spring-ioc的底层实现" class="header-anchor">#</a> 2.谈一下Spring IOC的底层实现</h2> <ul><li>先通过createBeanFactory创建出一个Bean工厂，DefaultListableBeanFactory</li> <li>开始循环创建对象，因为容器中的bean都是单例的，所有优先通过getBean、doGetBean从容器中查找，找不到的话，通过createBean、doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参的构造方法（getDeclareConstructor， newInstance）</li> <li>进行对象的属性填充 populateBean</li> <li>进行其他初始化操作 initializingBean</li></ul> <h2 id="_3-描述一下生命周期"><a href="#_3-描述一下生命周期" class="header-anchor">#</a> 3.描述一下生命周期</h2> <img src="/post-ci/img/interview/spring1.png"> <ul><li>实例化Bean：反射的方式生成对象</li> <li>填充Bean的属性：populateBean，此处由循环依赖问题引出三级缓存概念</li> <li>调用aware接口相关方法
<ul><li>如果Bean实现了BeanNameAware接口，则调用setBeanName(…)；</li> <li>如果Bean实现了BeanFactoryAware接口，则调用setBeanFactory(…)；</li> <li>如果Bean实现了BeanClassLoaderAware接口，则调用setBeanClassLoader(…)；；</li> <li>如果Bean实现了ApplicationContextAware接口，则调用setApplicationContext(…)；</li></ul></li> <li>调用BeanPostProcessor中的前置处理方法：postProcessorBeforeInitialization</li> <li>调用InitializingBean的afterPropertiesSet</li> <li>调用BeanPostProcessor中的后置处理方法：postProcessorAfterInitialization，
<ul><li>AOP就是在此处实现，AbstractAutoProxyCreator</li> <li>@PostConstruct方法回调</li></ul></li> <li>获取到完整的对象，可以用getBean的方式来进行对象的获取</li> <li>销毁流程
<ul><li>@PreDestroy注释，注释回调方法上，销毁Bean之前调用；</li> <li>实现DisposableBean接口，调用destroy(…)，销毁Bean之前调用；</li> <li>Bean定义中包含destroy-method（在XML中标签的属性）或@Bean(destroyMethod=&quot;…&quot;)指定的方法，销毁Bean之前调用；</li></ul></li></ul> <h2 id="_4-spring如何解决循环依赖问题"><a href="#_4-spring如何解决循环依赖问题" class="header-anchor">#</a> 4.Spring如何解决循环依赖问题</h2> <p>三点：三级缓存、提前暴露对象、aop</p> <h6 id="_1-总"><a href="#_1-总" class="header-anchor">#</a> （1）总</h6> <ul><li>什么是循环依赖问题，A依赖B，B依赖A</li></ul> <h6 id="_2-分-2"><a href="#_2-分-2" class="header-anchor">#</a> （2）分</h6> <ul><li>先说明bean的创建过程：实例化，初始化（属性填充）形成闭环的原因：
<ul><li>先创建A对象，实例化A对象，此时A对象中的b属性为空</li> <li>从容器中查找B对象，如果找到了，直接赋值，找不到直接创建B对象</li> <li>实例化B对象，此时B对象中的a属性为空，填充属性a</li> <li>容器中查找A对象，找不到，直接创建</li></ul></li> <li>解决方法：
<ul><li>此时A对象是存在的，但是此时A对象不是一个完整的状态，只完成了实例化，未完成初始化</li> <li>而所有的对象完成实例化和初始化之后，需要把完整的对象放到容器中，此时在容器中存在对象的几个状态：完成实例化但未初始化、完整状态，因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为查找顺序是1级-2级-3级这样的方式来查找的，一级缓存中放的是完整的对象（单例池），二级缓存中放的是非完整对象。</li> <li>为什么要有三级缓存？三级缓存的value是ObjectFactory，是一个函数式接口，存在的意义是保证整个容器的运行过程中同名的bean只有一个</li> <li>如果一个对象需要被代理，或者说需要生成代理对象，那么要优先生成一个普通对象，</li> <li>普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际调用过程中，是没有办法确定什么时候对象被使用，所有就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()</li> <li>因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</li></ul></li></ul> <h6 id="_3-另一种回答"><a href="#_3-另一种回答" class="header-anchor">#</a> （3）另一种回答</h6> <p>Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p> <h6 id="_4-缓存的放置时间和删除时间"><a href="#_4-缓存的放置时间和删除时间" class="header-anchor">#</a> （4）缓存的放置时间和删除时间</h6> <ul><li>三级缓存：createBeanInstance之后，addSingletonFactory</li> <li>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候，同时删除三级缓存getSingleton</li> <li>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存，addSingleton</li></ul> <h2 id="_5-beanfactory和factorybean区别"><a href="#_5-beanfactory和factorybean区别" class="header-anchor">#</a> 5.BeanFactory和FactoryBean区别</h2> <h6 id="_1-相同点"><a href="#_1-相同点" class="header-anchor">#</a> （1）相同点</h6> <ul><li>都是用来创建bean对象</li></ul> <h6 id="_2-不同点"><a href="#_2-不同点" class="header-anchor">#</a> （2）不同点</h6> <ul><li>当使用BeanFactory创建bean对象时，必须要遵循严格的生命周期流程，过于复杂</li> <li>如果想要简单的自定义某个对象的创建，同时创建完成的对象交给spring管理，那么就需要实现FactoryBean接口了
<ul><li>isSingleton:是否是单例对象</li> <li>getObjectType：获取返回对象的类型</li> <li>getObject：自定义创建对象的过程（new、反射、动态代理）</li></ul></li></ul> <h2 id="_6-spring中用到的设计模式"><a href="#_6-spring中用到的设计模式" class="header-anchor">#</a> 6.Spring中用到的设计模式</h2> <ul><li>单例模式：bean默认都是单例模式</li> <li>原型模式：指定作用域为prototype</li> <li>工厂模式：beanFactory</li> <li>模板方法</li> <li>适配器模式：Adapter</li> <li>策略模式</li> <li>装饰者模式</li> <li>责任链模式：aop拦截器链</li> <li>代理模式：动态代理</li> <li>观察者模式：</li> <li>委托者模式</li> <li>门面模式</li></ul> <h2 id="_7-spring的aop的底层实现"><a href="#_7-spring的aop的底层实现" class="header-anchor">#</a> 7.Spring的AOP的底层实现</h2> <p>动态代理
aop是ioc的一个扩展功能，现有ioc，再有aop，只是在ioc的整个流程中新增的一个扩展点而已：BeanPostProcessor</p> <h6 id="_1-总-2"><a href="#_1-总-2" class="header-anchor">#</a> （1）总:</h6> <ul><li>aop概念</li> <li>应用场景</li> <li>动态代理</li></ul> <h6 id="_2-分-3"><a href="#_2-分-3" class="header-anchor">#</a> （2）分</h6> <ul><li>bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现</li> <li>代理对象的创建过程（advice、切面、切点）</li> <li>通过jdk或者cglib的方式来生成代理对象（jdk代理是继承proxy，单继承，cglib是实现接口，多继承）</li> <li>在执行方法调用的时候，会调用到生成的字节码到文件中，直接会找到DynamicAdvisedInterceptor类中的Intercept方法，从此方法开始执行。</li> <li>根据之前定义好的advice来生成拦截器链</li> <li>从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个 InvocationInterceptor的对象，找的时候从-1的位置依次开始查找，执行</li></ul> <h2 id="_8-spring的事务是如何回滚的"><a href="#_8-spring的事务是如何回滚的" class="header-anchor">#</a> 8.Spring的事务是如何回滚的</h2> <p>spring的事务管理按照AOP实现时：</p> <ul><li>在before切面建立连接，开启事务</li> <li>执行业务逻辑，即sql操作</li> <li>执行成功时在after切面中commit</li> <li>执行失败时在afterThrowing切面中rollback</li></ul> <p>实际事务管理只是使用AOP的逻辑实现，但是并不是使用AOP的通知实现的</p> <h6 id="_1-总-3"><a href="#_1-总-3" class="header-anchor">#</a> （1）总</h6> <p>spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInterceptor来实现的，然后调用invoke来实现具体的逻辑</p> <h6 id="_2-分-4"><a href="#_2-分-4" class="header-anchor">#</a> （2）分</h6> <ol><li>先做准备工作，解析各个方法上事务相关的属性（隔离性、传播特性等）</li> <li>根据具体的属性来判断是否开启新事务</li> <li>当需要开启的时候，获取数据库的连接，关闭自动提交功能，开启事务</li> <li>执行具体的sql逻辑操作</li> <li>在操作过程中，执行失败了，那么会通过completeTransactionAfterThrowing来完成事务的回滚操作，回滚的具体逻辑通过doRollBack方法来实现的，实现的时候也要是先获取连接对象，通过连接对象来回滚</li> <li>如果执行过程中没有任何异常发生，那么通过commitTransactionAfterRunning来完成事务的提交操作，提交的具体逻辑通过doCommit方法来实现，，实现的时候也要是先获取连接对象，通过连接对象来提交</li> <li>当事务执行完毕，需要清除相关的事务信息cleanupTransactionInfo</li></ol> <p><code>疑问：为什么事务不通过Advice的方式来实现呢？</code></p> <h2 id="_9-谈一下spring的事务传播"><a href="#_9-谈一下spring的事务传播" class="header-anchor">#</a> 9.谈一下Spring的事务传播</h2> <p>传播特性有7种</p> <ul><li>Required</li> <li>Requires_new</li> <li>nested</li> <li>Support</li> <li>Not_Support</li> <li>Never</li> <li>Mandatory</li></ul> <p>某个事务嵌套另一个事务的时候怎么办？
A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？</p> <h6 id="_1-总-4"><a href="#_1-总-4" class="header-anchor">#</a> （1）总</h6> <p>事务的传播特性指的是不同的方法的嵌套调用过程中，事务应该如何进行处理，使用同一个事务还是不同的事务，当出现异常的时候时回滚还是提交，两方法之间的相关影响，在日常工作中，使用比较多的是：Required、Requires_new、nested</p> <h6 id="_2-分-5"><a href="#_2-分-5" class="header-anchor">#</a> （2）分</h6> <ol><li>先说事务的不同分类，可以分为三个：支持当前事务，不支持当前事务，嵌套事务</li> <li>如果外层方法是Required，内层方法是Required、Requires_new、nested</li> <li>如果外层方法是Requires_new，内层方法是Required、Requires_new、nested</li> <li>如果外层方法是nested，内层方法是Required、Requires_new、nested</li></ol> <p>核心处理逻辑非常简单：</p> <ol><li>判断内外方法是否是同一个事务：
<ol><li>是：异常统一在外层处理</li> <li>内层方法可能会影响到外层方法，但是外层方法不会影响内层方法（nested是特例）</li></ol></li></ol></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2022-12-02
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : 2023-04-09
    </span></section> <section class="post-links" data-v-4e23451f><a href="/post-ci/posts/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html" class="post-link" data-v-4e23451f>
      上一篇 : 微服务
    </a> <a href="/post-ci/posts/2022/12/02/jvm%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html" class="post-link" data-v-4e23451f>
      下一篇 : jvm面试题
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(http://img.icoisini.xyz/wx-background.jpg);" data-v-9d847660><img src="http://img.icoisini.xyz/cm.jpg" alt="小二哥" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      小二哥
    </section> <section class="info-desc" data-v-9d847660>Don`t Worry Be Happy!</section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="DaLian City, China" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>DaLian City, China</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          DaLian City, China
        </span></span></section> <section data-v-9d847660><span title="DaLian University of Technology" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>DaLian University of Technology</title><use xlink:href="#icon-organization" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          DaLian University of Technology
        </span></span></section> <section data-v-9d847660><a href="mailto:csrsming@163.com" title="csrsming@163.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>csrsming@163.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          csrsming@163.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/csrsm" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: csrsm" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: csrsm</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_1-谈谈对spring-ioc的理解-原理和实现">1.谈谈对Spring IOC的理解，原理和实现？</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_2-谈一下spring-ioc的底层实现">2.谈一下Spring IOC的底层实现</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_3-描述一下生命周期">3.描述一下生命周期</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_4-spring如何解决循环依赖问题">4.Spring如何解决循环依赖问题</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_5-beanfactory和factorybean区别">5.BeanFactory和FactoryBean区别</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_6-spring中用到的设计模式">6.Spring中用到的设计模式</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_7-spring的aop的底层实现">7.Spring的AOP的底层实现</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_8-spring的事务是如何回滚的">8.Spring的事务是如何回滚的</a></li><li><a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#_9-谈一下spring的事务传播">9.谈一下Spring的事务传播</a></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/post-ci/posts/2022/12/02/spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-1375e54c><p class="footer-sns-links" data-v-1375e54c><a href="https://github.com/csrsm" target="_blank" class="sns-link" data-v-1375e54c><span title="GitHub: csrsm" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>GitHub: csrsm</title><use xlink:href="#icon-github" data-v-1375e54c data-v-1375e54c></use></svg></span></a></p> <!----> <p class="footer-text" data-v-1375e54c>Copyright 2016-present <a href="https://github.com/csrsm" target="_blank">csrsm</a></p></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/post-ci/assets/js/app.d7fff394.js" defer></script><script src="/post-ci/assets/js/7.8eaaf042.js" defer></script><script src="/post-ci/assets/js/28.8186bd22.js" defer></script>
  </body>
</html>
